<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>HiveBoard — Mission Control</title>
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600;700&family=DM+Sans:wght@400;500;600;700&display=swap" rel="stylesheet">
<style>
  /* ═══════════════════════════════════════════
     C2.1 — STATIC SHELL & THEMING
     ═══════════════════════════════════════════ */

  /* C2.1.2 — CSS Design Tokens */
  :root {
    --idle: #6b7280;
    --active: #3b82f6;
    --success: #10b981;
    --warning: #f59e0b;
    --error: #ef4444;
    --stuck: #dc2626;
    --llm: #8b5cf6;

    --bg-deep: #0a0c10;
    --bg-primary: #0f1117;
    --bg-card: #161922;
    --bg-elevated: #1c2030;
    --bg-hover: #232838;
    --border: #2a2f3e;
    --border-subtle: #1e2332;

    --text-primary: #e8eaed;
    --text-secondary: #9ca3af;
    --text-muted: #6b7280;

    --accent: #f59e0b;
    --accent-dim: rgba(245, 158, 11, 0.15);

    --font-mono: 'JetBrains Mono', monospace;
    --font-sans: 'DM Sans', sans-serif;
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    font-family: var(--font-sans);
    background: var(--bg-deep);
    color: var(--text-primary);
    overflow: hidden;
    height: 100vh;
  }

  /* C2.1.1 — Top Bar (48px) */
  .topbar {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 0 20px;
    height: 48px;
    background: var(--bg-primary);
    border-bottom: 1px solid var(--border);
    flex-shrink: 0;
  }

  .topbar-left { display: flex; align-items: center; gap: 12px; }

  .logo {
    display: flex;
    align-items: center;
    gap: 8px;
    font-family: var(--font-mono);
    font-weight: 700;
    font-size: 15px;
    letter-spacing: -0.5px;
  }

  .logo-hex {
    width: 26px; height: 26px;
    background: var(--accent);
    clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
    display: flex; align-items: center; justify-content: center; flex-shrink: 0;
  }

  .logo-hex-inner {
    width: 18px; height: 18px;
    background: var(--bg-primary);
    clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
  }

  .logo span { color: var(--accent); }

  .workspace-badge {
    font-family: var(--font-mono); font-size: 11px; color: var(--text-muted);
    background: var(--bg-elevated); padding: 3px 10px; border-radius: 4px;
    border: 1px solid var(--border-subtle);
  }

  /* C2.1.1 — View Tabs */
  .view-tabs { display: flex; gap: 2px; background: var(--bg-deep); padding: 3px; border-radius: 6px; }

  .view-tab {
    font-family: var(--font-mono); font-size: 11px; font-weight: 500;
    color: var(--text-muted); padding: 4px 14px; border-radius: 4px;
    cursor: pointer; transition: all 0.15s; border: none; background: transparent; white-space: nowrap;
  }
  .view-tab:hover { color: var(--text-secondary); }
  .view-tab.active { background: var(--bg-elevated); color: var(--accent); }

  .topbar-right { display: flex; align-items: center; gap: 16px; }

  /* C2.1.4 — Status Pill with pulse animation */
  .status-pill { display: flex; align-items: center; gap: 6px; font-family: var(--font-mono); font-size: 11px; color: var(--text-secondary); }
  .status-dot { width: 7px; height: 7px; border-radius: 50%; background: var(--success); animation: pulse-dot 2s ease infinite; }
  .status-dot.disconnected { background: var(--error); }

  @keyframes pulse-dot {
    0%, 100% { opacity: 1; box-shadow: 0 0 0 0 rgba(16, 185, 129, 0.4); }
    50% { opacity: 0.7; box-shadow: 0 0 0 4px rgba(16, 185, 129, 0); }
  }

  /* C2.1.1 — Environment Selector */
  .env-selector {
    font-family: var(--font-mono); font-size: 11px;
    background: var(--bg-card); border: 1px solid var(--border);
    color: var(--text-secondary); padding: 4px 10px; border-radius: 4px; cursor: pointer;
  }

  /* C2.1.5 — Global Filter Bar */
  .active-filter-bar {
    display: none; align-items: center; justify-content: center; gap: 10px;
    padding: 6px 20px; background: var(--accent-dim);
    border-bottom: 1px solid rgba(245, 158, 11, 0.25); flex-shrink: 0;
  }
  .active-filter-bar.visible { display: flex; }

  .filter-pill-global { font-family: var(--font-mono); font-size: 11px; color: var(--accent); display: flex; align-items: center; gap: 8px; }

  .filter-clear-btn {
    font-family: var(--font-mono); font-size: 10px; color: var(--text-muted);
    background: var(--bg-elevated); border: 1px solid var(--border);
    padding: 2px 10px; border-radius: 3px; cursor: pointer; transition: all 0.15s;
  }
  .filter-clear-btn:hover { border-color: var(--accent); color: var(--accent); }

  /* C2.1.1 — Main 3-region grid layout */
  .main-layout {
    display: grid; grid-template-columns: 280px 1fr 320px; grid-template-rows: 1fr;
    height: calc(100vh - 48px); gap: 0;
  }
  .main-layout.has-filter { height: calc(100vh - 48px - 33px); }

  /* ═══════════════════════════════════════════
     C2.2 — THE HIVE PANEL (Left Sidebar)
     ═══════════════════════════════════════════ */
  .hive-panel { background: var(--bg-primary); border-right: 1px solid var(--border); display: flex; flex-direction: column; overflow: hidden; }

  .panel-header {
    padding: 14px 16px; border-bottom: 1px solid var(--border-subtle);
    display: flex; align-items: center; justify-content: space-between; flex-shrink: 0;
  }
  .panel-title { font-family: var(--font-mono); font-size: 11px; font-weight: 600; text-transform: uppercase; letter-spacing: 1.2px; color: var(--text-muted); }
  .panel-header-right { display: flex; align-items: center; gap: 8px; }
  .panel-count { font-family: var(--font-mono); font-size: 11px; color: var(--text-muted); background: var(--bg-elevated); padding: 2px 8px; border-radius: 3px; }

  /* C2.2.1 — Attention Badge */
  .attention-badge {
    font-family: var(--font-mono); font-size: 10px; font-weight: 700; color: #fff;
    background: var(--error); padding: 1px 7px; border-radius: 8px;
    animation: attention-pulse 2s ease infinite;
  }
  @keyframes attention-pulse {
    0%, 100% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.4); }
    50% { box-shadow: 0 0 0 4px rgba(239, 68, 68, 0); }
  }

  /* C2.1.6 — Scrollbar Styling */
  .hive-list { flex: 1; overflow-y: auto; padding: 8px; }
  .hive-list::-webkit-scrollbar { width: 4px; }
  .hive-list::-webkit-scrollbar-track { background: transparent; }
  .hive-list::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }

  /* C2.2.2 — Agent Card */
  .agent-card {
    background: var(--bg-card); border: 1px solid var(--border-subtle); border-radius: 8px;
    padding: 12px; margin-bottom: 6px; cursor: pointer; transition: all 0.15s ease; position: relative;
  }
  .agent-card:hover { background: var(--bg-hover); border-color: var(--border); }
  .agent-card.selected { border-color: var(--accent); background: var(--accent-dim); }

  .agent-card-top { display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px; }
  .agent-name { font-family: var(--font-mono); font-size: 13px; font-weight: 600; color: var(--text-primary); }

  .agent-status-badge { font-family: var(--font-mono); font-size: 9px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.8px; padding: 2px 8px; border-radius: 3px; }
  .badge-processing { background: rgba(59, 130, 246, 0.15); color: var(--active); }
  .badge-idle { background: rgba(107, 114, 128, 0.15); color: var(--idle); }
  .badge-error { background: rgba(239, 68, 68, 0.15); color: var(--error); }
  .badge-stuck { background: rgba(220, 38, 38, 0.2); color: var(--stuck); animation: stuck-blink 1.5s ease infinite; }
  .badge-waiting { background: rgba(245, 158, 11, 0.15); color: var(--warning); }
  .badge-completed { background: rgba(16, 185, 129, 0.15); color: var(--success); }

  @keyframes stuck-blink { 0%, 100% { opacity: 1; } 50% { opacity: 0.4; } }

  .agent-card-meta { display: flex; align-items: center; gap: 10px; font-size: 11px; color: var(--text-muted); }
  .agent-type-label { font-family: var(--font-mono); font-size: 10px; color: var(--text-muted); background: var(--bg-deep); padding: 1px 6px; border-radius: 3px; }
  .heartbeat-indicator { display: flex; align-items: center; gap: 4px; font-family: var(--font-mono); font-size: 10px; }
  .hb-dot { width: 5px; height: 5px; border-radius: 50%; }
  .hb-fresh { background: var(--success); }
  .hb-stale { background: var(--warning); }
  .hb-dead { background: var(--error); }

  /* C2.2.3 — Pipeline enrichment on cards */
  .agent-card-pipeline { display: flex; align-items: center; gap: 8px; margin-top: 6px; flex-wrap: wrap; }
  .queue-badge { font-family: var(--font-mono); font-size: 9px; font-weight: 600; color: var(--active); background: rgba(59, 130, 246, 0.12); padding: 1px 6px; border-radius: 3px; letter-spacing: 0.3px; }
  .queue-badge.high { color: var(--warning); background: rgba(245, 158, 11, 0.12); }
  .issue-indicator { display: flex; align-items: center; gap: 3px; font-family: var(--font-mono); font-size: 9px; color: var(--error); }
  .issue-dot { width: 5px; height: 5px; border-radius: 50%; background: var(--error); }
  .processing-line { font-family: var(--font-mono); font-size: 9px; color: var(--text-muted); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 200px; }

  .agent-task-info { margin-top: 8px; padding-top: 8px; border-top: 1px solid var(--border-subtle); font-family: var(--font-mono); font-size: 10px; color: var(--text-secondary); display: flex; align-items: center; gap: 6px; }
  .clickable-entity { cursor: pointer; transition: color 0.1s; }
  .clickable-entity:hover { color: var(--accent) !important; text-decoration: underline; text-underline-offset: 2px; }

  /* C2.2.4 — Sparkline chart */
  .sparkline-row { margin-top: 8px; display: flex; align-items: flex-end; gap: 2px; height: 20px; }
  .spark-bar { flex: 1; min-width: 3px; border-radius: 1px 1px 0 0; opacity: 0.5; transition: opacity 0.2s; }
  .agent-card:hover .spark-bar { opacity: 0.8; }

  /* ═══════════════════════════════════════════
     C2.3 — CENTER PANEL
     ═══════════════════════════════════════════ */
  .center-panel { display: flex; flex-direction: column; overflow: hidden; }
  .center-view { display: none; flex-direction: column; flex: 1; overflow: hidden; }
  .center-view.active { display: flex; }

  /* C2.3.1a — Summary statistics bar */
  .summary-bar { display: flex; gap: 1px; padding: 0; background: var(--border-subtle); flex-shrink: 0; }
  .summary-stat { flex: 1; background: var(--bg-primary); padding: 12px 16px; display: flex; flex-direction: column; gap: 2px; transition: background 0.15s; }
  .summary-stat.clickable { cursor: pointer; }
  .summary-stat.clickable:hover { background: var(--bg-elevated); }
  .summary-stat.active-filter-stat { background: var(--accent-dim); }
  .summary-stat:first-child { padding-left: 20px; }
  .stat-label { font-family: var(--font-mono); font-size: 10px; text-transform: uppercase; letter-spacing: 0.8px; color: var(--text-muted); }
  .stat-value { font-family: var(--font-mono); font-size: 20px; font-weight: 700; color: var(--text-primary); font-variant-numeric: tabular-nums; }
  .stat-value.green { color: var(--success); }
  .stat-value.amber { color: var(--warning); }
  .stat-value.red { color: var(--error); }
  .stat-value.blue { color: var(--active); }
  .stat-value.purple { color: var(--llm); }

  /* C2.3.1b — Mini-chart metrics row */
  .metrics-row { display: flex; gap: 1px; background: var(--border-subtle); flex-shrink: 0; }
  .metric-cell { flex: 1; background: var(--bg-primary); padding: 10px 14px; display: flex; flex-direction: column; gap: 4px; }
  .metric-chart { display: flex; align-items: flex-end; gap: 2px; height: 24px; }
  .metric-bar { flex: 1; border-radius: 1px 1px 0 0; min-width: 4px; transition: height 0.3s ease; }

  /* C2.3.1c — Tasks Table */
  .tasks-table-section { flex-shrink: 0; max-height: 200px; overflow-y: auto; border-top: 1px solid var(--border); }
  .tasks-table-section::-webkit-scrollbar { width: 4px; }
  .tasks-table-section::-webkit-scrollbar-track { background: transparent; }
  .tasks-table-section::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }

  .tasks-table { width: 100%; border-collapse: collapse; font-family: var(--font-mono); font-size: 11px; }
  .tasks-table thead { position: sticky; top: 0; z-index: 5; background: var(--bg-primary); }
  .tasks-table th { text-align: left; padding: 8px 12px; font-size: 10px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.8px; color: var(--text-muted); border-bottom: 1px solid var(--border); }
  .tasks-table td { padding: 8px 12px; border-bottom: 1px solid var(--border-subtle); color: var(--text-secondary); }
  .tasks-table tr { cursor: pointer; transition: background 0.1s; }
  .tasks-table tbody tr:hover { background: var(--bg-hover); }
  .tasks-table tbody tr.selected-row { background: var(--accent-dim); }
  .task-status-dot { display: inline-block; width: 6px; height: 6px; border-radius: 50%; margin-right: 6px; vertical-align: middle; }
  .task-duration { font-variant-numeric: tabular-nums; }
  .task-llm-badge { font-family: var(--font-mono); font-size: 9px; color: var(--llm); background: rgba(139, 92, 246, 0.1); padding: 1px 5px; border-radius: 2px; }

  /* C2.3.1d-h — Timeline */
  .timeline-section { flex: 1; display: flex; flex-direction: column; overflow: hidden; min-height: 0; }
  .timeline-header { padding: 14px 20px; border-bottom: 1px solid var(--border-subtle); display: flex; align-items: center; justify-content: space-between; flex-shrink: 0; background: var(--bg-primary); }
  .timeline-header-left { display: flex; align-items: center; gap: 12px; }
  .timeline-task-id { font-family: var(--font-mono); font-size: 13px; font-weight: 600; color: var(--accent); }
  .timeline-task-meta { font-family: var(--font-mono); font-size: 11px; color: var(--text-muted); display: flex; gap: 16px; }
  .timeline-task-meta span { display: flex; align-items: center; gap: 4px; }

  /* C2.3.1e — Plan progress bar */
  .plan-bar { display: none; padding: 8px 20px; background: var(--bg-primary); border-bottom: 1px solid var(--border-subtle); flex-shrink: 0; }
  .plan-bar.visible { display: block; }
  .plan-bar-header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 6px; }
  .plan-bar-label { font-family: var(--font-mono); font-size: 10px; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.5px; }
  .plan-bar-progress { font-family: var(--font-mono); font-size: 10px; color: var(--text-secondary); }
  .plan-steps { display: flex; gap: 3px; height: 16px; }
  .plan-step { flex: 1; border-radius: 3px; position: relative; cursor: default; }
  .plan-step.completed { background: var(--success); opacity: 0.7; }
  .plan-step.active { background: var(--active); animation: plan-pulse 1.5s ease infinite; }
  .plan-step.failed { background: var(--error); opacity: 0.7; }
  .plan-step.pending { background: var(--bg-elevated); border: 1px solid var(--border); }
  .plan-step.skipped { background: var(--idle); opacity: 0.3; }
  @keyframes plan-pulse { 0%, 100% { opacity: 0.7; } 50% { opacity: 1; } }
  .plan-step-tooltip { display: none; position: absolute; bottom: 100%; left: 50%; transform: translateX(-50%); background: var(--bg-elevated); border: 1px solid var(--border); border-radius: 4px; padding: 4px 8px; font-family: var(--font-mono); font-size: 9px; color: var(--text-secondary); white-space: nowrap; z-index: 10; margin-bottom: 4px; }
  .plan-step:hover .plan-step-tooltip { display: block; }

  /* C2.3.1f — Timeline visualization */
  .timeline-canvas { flex: 1; overflow-x: auto; overflow-y: auto; padding: 40px 20px 20px; background: var(--bg-deep); position: relative; min-height: 0; }
  .timeline-canvas::-webkit-scrollbar { height: 6px; width: 6px; }
  .timeline-canvas::-webkit-scrollbar-track { background: var(--bg-deep); }
  .timeline-canvas::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }
  .timeline-track { display: flex; align-items: center; gap: 0; min-width: max-content; padding: 10px 0; position: relative; }
  .tl-node { display: flex; flex-direction: column; align-items: center; position: relative; cursor: pointer; }
  .tl-node-dot { width: 14px; height: 14px; border-radius: 50%; border: 2px solid; background: var(--bg-deep); z-index: 2; transition: transform 0.15s ease, box-shadow 0.15s ease; }
  .tl-node:hover .tl-node-dot { transform: scale(1.4); }
  .tl-node.pinned .tl-node-dot { transform: scale(1.4); box-shadow: 0 0 0 3px rgba(245, 158, 11, 0.3); }
  .tl-node.llm-node .tl-node-dot { border-color: var(--llm); border-radius: 4px; width: 16px; height: 16px; }
  .tl-node.llm-node .tl-node-label { color: var(--llm); }
  .tl-llm-badge { position: absolute; top: -42px; font-family: var(--font-mono); font-size: 8px; color: var(--llm); background: rgba(139, 92, 246, 0.12); padding: 1px 5px; border-radius: 2px; white-space: nowrap; }
  .tl-node-label { position: absolute; top: -28px; font-family: var(--font-mono); font-size: 10px; font-weight: 500; white-space: nowrap; color: var(--text-secondary); transition: color 0.1s; }
  .tl-node:hover .tl-node-label, .tl-node.pinned .tl-node-label { color: var(--text-primary); }
  .tl-node-time { position: absolute; bottom: -22px; font-family: var(--font-mono); font-size: 9px; color: var(--text-muted); white-space: nowrap; }
  .tl-connector { height: 2px; min-width: 40px; position: relative; display: flex; align-items: center; justify-content: center; }
  .tl-connector-line { width: 100%; height: 2px; }
  .tl-connector-duration { position: absolute; font-family: var(--font-mono); font-size: 9px; color: var(--text-muted); top: -16px; white-space: nowrap; background: var(--bg-deep); padding: 0 4px; }

  /* C2.3.1h — Pinned node detail */
  .pinned-detail { flex-shrink: 0; background: var(--bg-elevated); border-top: 1px solid var(--border); display: none; overflow: hidden; }
  .pinned-detail.visible { display: block; }
  .pinned-detail-header { display: flex; align-items: center; justify-content: space-between; padding: 10px 16px; border-bottom: 1px solid var(--border-subtle); }
  .pinned-detail-title { font-family: var(--font-mono); font-size: 12px; font-weight: 600; }
  .pinned-detail-close { font-family: var(--font-mono); font-size: 11px; color: var(--text-muted); cursor: pointer; background: none; border: 1px solid var(--border); padding: 2px 8px; border-radius: 3px; transition: all 0.15s; }
  .pinned-detail-close:hover { border-color: var(--accent); color: var(--accent); }
  .pinned-detail-body { padding: 12px 16px; display: flex; gap: 24px; flex-wrap: wrap; }
  .detail-col { display: flex; flex-direction: column; gap: 4px; min-width: 140px; }
  .detail-row { display: flex; justify-content: space-between; gap: 16px; font-family: var(--font-mono); font-size: 11px; }
  .detail-key { color: var(--text-muted); }
  .detail-val { color: var(--text-secondary); }
  .detail-payload-tag { display: inline-block; font-family: var(--font-mono); font-size: 9px; padding: 1px 6px; border-radius: 3px; background: var(--bg-card); border: 1px solid var(--border-subtle); color: var(--text-muted); margin-right: 4px; margin-top: 4px; }

  /* C2.3.3 — Agent Detail View */
  .agent-detail-header { display: flex; align-items: center; justify-content: space-between; padding: 14px 20px; background: var(--bg-primary); border-bottom: 1px solid var(--border); flex-shrink: 0; }
  .agent-detail-identity { display: flex; align-items: center; gap: 12px; }
  .agent-detail-name { font-family: var(--font-mono); font-size: 15px; font-weight: 700; color: var(--text-primary); }
  .agent-detail-close { font-family: var(--font-mono); font-size: 11px; color: var(--text-muted); cursor: pointer; background: none; border: 1px solid var(--border); padding: 4px 12px; border-radius: 4px; transition: all 0.15s; }
  .agent-detail-close:hover { border-color: var(--accent); color: var(--accent); }
  .detail-tabs { display: flex; gap: 0; background: var(--bg-primary); border-bottom: 1px solid var(--border); flex-shrink: 0; padding: 0 20px; }
  .detail-tab { font-family: var(--font-mono); font-size: 11px; font-weight: 500; color: var(--text-muted); padding: 10px 16px; cursor: pointer; border-bottom: 2px solid transparent; transition: all 0.15s; }
  .detail-tab:hover { color: var(--text-secondary); }
  .detail-tab.active { color: var(--accent); border-bottom-color: var(--accent); }
  .detail-tab-content { display: none; flex: 1; overflow-y: auto; padding: 16px 20px; background: var(--bg-deep); }
  .detail-tab-content.active { display: block; }
  .detail-tab-content::-webkit-scrollbar { width: 4px; }
  .detail-tab-content::-webkit-scrollbar-track { background: transparent; }
  .detail-tab-content::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }

  /* Pipeline tables */
  .pipeline-section { margin-bottom: 24px; }
  .pipeline-section-header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px; }
  .pipeline-section-title { font-family: var(--font-mono); font-size: 11px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.8px; color: var(--text-muted); }
  .pipeline-badge { font-family: var(--font-mono); font-size: 10px; padding: 2px 8px; border-radius: 3px; background: var(--bg-elevated); color: var(--text-muted); }
  .pipeline-table { width: 100%; border-collapse: collapse; font-family: var(--font-mono); font-size: 11px; background: var(--bg-card); border-radius: 6px; overflow: hidden; border: 1px solid var(--border-subtle); }
  .pipeline-table th { text-align: left; padding: 8px 12px; font-size: 9px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; color: var(--text-muted); background: var(--bg-elevated); border-bottom: 1px solid var(--border); }
  .pipeline-table td { padding: 8px 12px; border-bottom: 1px solid var(--border-subtle); color: var(--text-secondary); }
  .pipeline-table tr:last-child td { border-bottom: none; }
  .priority-badge { font-family: var(--font-mono); font-size: 9px; padding: 1px 6px; border-radius: 2px; font-weight: 600; }
  .priority-high { background: rgba(239, 68, 68, 0.12); color: var(--error); }
  .priority-normal { background: rgba(59, 130, 246, 0.12); color: var(--active); }
  .priority-low { background: rgba(107, 114, 128, 0.12); color: var(--idle); }
  .severity-badge { font-family: var(--font-mono); font-size: 9px; padding: 1px 6px; border-radius: 2px; font-weight: 600; }
  .severity-critical { background: rgba(220, 38, 38, 0.15); color: var(--stuck); }
  .severity-high { background: rgba(239, 68, 68, 0.12); color: var(--error); }
  .severity-medium { background: rgba(245, 158, 11, 0.12); color: var(--warning); }
  .pipeline-empty { padding: 16px; text-align: center; font-family: var(--font-mono); font-size: 11px; color: var(--text-muted); background: var(--bg-card); border-radius: 6px; border: 1px solid var(--border-subtle); }

  /* C2.3.2 — Cost Explorer */
  .cost-ribbon { display: flex; gap: 1px; background: var(--border-subtle); flex-shrink: 0; }
  .cost-stat { flex: 1; background: var(--bg-primary); padding: 16px 20px; display: flex; flex-direction: column; gap: 4px; }
  .cost-tables { flex: 1; overflow-y: auto; padding: 16px 20px; display: flex; flex-direction: column; gap: 20px; }
  .cost-tables::-webkit-scrollbar { width: 4px; }
  .cost-tables::-webkit-scrollbar-track { background: transparent; }
  .cost-tables::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }
  .cost-section-title { font-family: var(--font-mono); font-size: 11px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.8px; color: var(--text-muted); margin-bottom: 8px; }
  .cost-table { width: 100%; border-collapse: collapse; font-family: var(--font-mono); font-size: 11px; background: var(--bg-card); border-radius: 6px; overflow: hidden; border: 1px solid var(--border-subtle); }
  .cost-table th { text-align: left; padding: 8px 14px; font-size: 10px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; color: var(--text-muted); background: var(--bg-elevated); border-bottom: 1px solid var(--border); }
  .cost-table td { padding: 8px 14px; border-bottom: 1px solid var(--border-subtle); color: var(--text-secondary); }
  .cost-table tr:last-child td { border-bottom: none; }
  .cost-bar { height: 4px; border-radius: 2px; background: var(--llm); opacity: 0.6; margin-top: 4px; }
  .model-badge { font-family: var(--font-mono); font-size: 9px; padding: 2px 6px; border-radius: 3px; background: rgba(139, 92, 246, 0.1); color: var(--llm); }

  /* ═══════════════════════════════════════════
     C2.4 — ACTIVITY STREAM (Right Sidebar)
     ═══════════════════════════════════════════ */
  .stream-panel { background: var(--bg-primary); border-left: 1px solid var(--border); display: flex; flex-direction: column; overflow: hidden; }
  .stream-filters { padding: 8px 12px; display: flex; gap: 4px; flex-wrap: wrap; border-bottom: 1px solid var(--border-subtle); flex-shrink: 0; }
  .filter-chip { font-family: var(--font-mono); font-size: 10px; padding: 2px 8px; border-radius: 3px; border: 1px solid var(--border-subtle); color: var(--text-muted); cursor: pointer; transition: all 0.1s; }
  .filter-chip:hover { border-color: var(--border); color: var(--text-secondary); }
  .filter-chip.active { background: var(--accent-dim); border-color: var(--accent); color: var(--accent); }
  .live-badge { display: flex; align-items: center; gap: 5px; font-family: var(--font-mono); font-size: 10px; color: var(--success); text-transform: uppercase; letter-spacing: 0.8px; }
  .live-dot { width: 6px; height: 6px; border-radius: 50%; background: var(--success); animation: pulse-dot 2s ease infinite; }
  .stream-list { flex: 1; overflow-y: auto; padding: 8px; }
  .stream-list::-webkit-scrollbar { width: 4px; }
  .stream-list::-webkit-scrollbar-track { background: transparent; }
  .stream-list::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }
  .stream-event { padding: 8px 10px; border-bottom: 1px solid var(--border-subtle); transition: background 0.1s; }
  .stream-event:hover { background: var(--bg-card); }
  .stream-event-top { display: flex; align-items: center; justify-content: space-between; margin-bottom: 3px; }
  .stream-event-type { font-family: var(--font-mono); font-size: 10px; font-weight: 500; display: flex; align-items: center; gap: 5px; }
  .event-type-dot { width: 5px; height: 5px; border-radius: 50%; flex-shrink: 0; }
  .event-kind-icon { font-size: 10px; margin-right: 2px; }
  .stream-event-time { font-family: var(--font-mono); font-size: 10px; color: var(--text-muted); }
  .stream-event-body { font-size: 12px; color: var(--text-secondary); line-height: 1.4; }
  .stream-event-agent { font-family: var(--font-mono); font-size: 10px; color: var(--text-muted); margin-bottom: 2px; }

  /* Misc */
  .permalink-btn { font-family: var(--font-mono); font-size: 11px; color: var(--text-muted); cursor: pointer; padding: 3px 10px; border: 1px solid var(--border); border-radius: 4px; transition: all 0.15s; }
  .permalink-btn:hover { border-color: var(--accent); color: var(--accent); }
  .urgency-glow { box-shadow: inset 0 0 0 1px rgba(239, 68, 68, 0.3), 0 0 12px rgba(239, 68, 68, 0.08); }
  .empty-state { display: flex; flex-direction: column; align-items: center; gap: 8px; padding: 40px 20px; color: var(--text-muted); font-size: 12px; text-align: center; }
  .empty-state-icon { font-size: 24px; opacity: 0.5; }
  .fade-in { animation: fadeIn 0.2s ease; }
  @keyframes fadeIn { from { opacity: 0; transform: translateY(4px); } to { opacity: 1; transform: translateY(0); } }

  /* Loading state */
  .loading-overlay { display: flex; align-items: center; justify-content: center; flex: 1; font-family: var(--font-mono); font-size: 12px; color: var(--text-muted); }
  .loading-spinner { width: 20px; height: 20px; border: 2px solid var(--border); border-top-color: var(--accent); border-radius: 50%; animation: spin 0.8s linear infinite; margin-right: 10px; }
  @keyframes spin { to { transform: rotate(360deg); } }

  /* Toast notifications */
  .toast-container { position: fixed; top: 60px; right: 20px; z-index: 100; display: flex; flex-direction: column; gap: 8px; }
  .toast { font-family: var(--font-mono); font-size: 11px; padding: 8px 14px; border-radius: 6px; background: var(--bg-elevated); border: 1px solid var(--border); color: var(--text-secondary); animation: fadeIn 0.2s ease; max-width: 300px; }
  .toast.error { border-color: var(--error); color: var(--error); }
</style>
</head>
<body>
  <div class="topbar">
    <div class="topbar-left">
      <div class="logo"><div class="logo-hex"><div class="logo-hex-inner"></div></div>Hive<span>Board</span></div>
      <div class="workspace-badge" id="workspaceBadge">—</div>
      <div class="view-tabs">
        <button class="view-tab active" onclick="switchView('mission')">Mission Control</button>
        <button class="view-tab" onclick="switchView('cost')">Cost Explorer</button>
      </div>
    </div>
    <div class="topbar-right">
      <div class="status-pill"><div class="status-dot" id="connectionDot"></div> <span id="connectionText">Connecting…</span></div>
      <select class="env-selector" id="envSelector" onchange="onEnvChange()"><option>production</option><option>staging</option></select>
    </div>
  </div>

  <div class="active-filter-bar" id="filterBar">
    <div class="filter-pill-global" id="filterPillText"></div>
    <button class="filter-clear-btn" onclick="clearGlobalFilter()">✕ Clear</button>
  </div>

  <div class="main-layout" id="mainLayout">
    <!-- LEFT: THE HIVE -->
    <div class="hive-panel">
      <div class="panel-header">
        <div style="display: flex; align-items: center; gap: 8px;">
          <div class="panel-title">The Hive</div>
          <div class="attention-badge" id="attentionBadge" style="display:none;"></div>
          <div class="panel-count" id="agentCount">0 agents</div>
        </div>
      </div>
      <div class="hive-list" id="hiveList">
        <div class="loading-overlay"><div class="loading-spinner"></div>Loading agents…</div>
      </div>
    </div>

    <!-- CENTER -->
    <div class="center-panel">
      <div class="center-view active" id="viewMission">
        <div class="summary-bar" id="summaryBar"></div>
        <div class="metrics-row" id="metricsRow"></div>
        <div class="timeline-section">
          <div class="timeline-header" id="timelineHeader">
            <div class="timeline-header-left">
              <div class="panel-title">Timeline</div>
              <div class="timeline-task-id" id="tlTaskId">—</div>
              <div class="timeline-task-meta" id="tlMeta"></div>
            </div>
            <div style="display: flex; gap: 8px; align-items: center;">
              <div class="permalink-btn" onclick="copyPermalink()">&#x29C9; Permalink</div>
            </div>
          </div>
          <div class="plan-bar" id="planBar">
            <div class="plan-bar-header">
              <div class="plan-bar-label" id="planLabel">Plan</div>
              <div class="plan-bar-progress" id="planProgress"></div>
            </div>
            <div class="plan-steps" id="planSteps"></div>
          </div>
          <div class="timeline-canvas" id="timelineCanvas">
            <div class="loading-overlay"><div class="loading-spinner"></div>Select a task…</div>
          </div>
          <div class="pinned-detail" id="pinnedDetail">
            <div class="pinned-detail-header">
              <div class="pinned-detail-title" id="pinnedTitle">—</div>
              <button class="pinned-detail-close" onclick="unpinDetail()">✕ Close</button>
            </div>
            <div class="pinned-detail-body" id="pinnedBody"></div>
          </div>
        </div>
        <div class="tasks-table-section">
          <table class="tasks-table">
            <thead><tr><th>Task ID</th><th>Agent</th><th>Type</th><th>Status</th><th>Duration</th><th>LLM</th><th>Cost</th><th>Time</th></tr></thead>
            <tbody id="tasksBody"></tbody>
          </table>
        </div>
      </div>

      <div class="center-view" id="viewAgentDetail">
        <div class="agent-detail-header">
          <div class="agent-detail-identity">
            <div class="agent-detail-name" id="detailAgentName">—</div>
            <div id="detailAgentBadge"></div>
          </div>
          <button class="agent-detail-close" onclick="closeAgentDetail()">✕ Close Detail</button>
        </div>
        <div class="detail-tabs" id="detailTabs">
          <div class="detail-tab active" onclick="switchDetailTab('tasks')">Tasks</div>
          <div class="detail-tab" onclick="switchDetailTab('pipeline')">Pipeline</div>
        </div>
        <div class="detail-tab-content active" id="detailTabTasks"></div>
        <div class="detail-tab-content" id="detailTabPipeline"></div>
      </div>

      <div class="center-view" id="viewCost">
        <div class="cost-ribbon" id="costRibbon"></div>
        <div class="cost-tables" id="costTables"></div>
      </div>
    </div>

    <!-- RIGHT: ACTIVITY STREAM -->
    <div class="stream-panel">
      <div class="panel-header">
        <div style="display: flex; align-items: center; gap: 10px;">
          <div class="panel-title">Activity</div>
          <div class="live-badge"><div class="live-dot"></div> Live</div>
        </div>
        <div class="panel-count" id="eventCount">0 events</div>
      </div>
      <div class="stream-filters" id="streamFilters"></div>
      <div class="stream-list" id="streamList"></div>
    </div>
  </div>

  <div class="toast-container" id="toastContainer"></div>

<script>
// ═══════════════════════════════════════════════════
//  C2.5 — CONFIGURATION
// ═══════════════════════════════════════════════════

const CONFIG = {
  // Auto-detect: same origin as dashboard, or default
  endpoint: window.location.origin,
  apiKey: 'hb_live_simulator_key_00000000',
  wsEndpoint: null, // derived from endpoint
  pollInterval: 5000,
  maxStreamEvents: 50,
};

// Derive WS endpoint
(function() {
  const url = new URL(CONFIG.endpoint);
  CONFIG.wsEndpoint = (url.protocol === 'https:' ? 'wss:' : 'ws:') + '//' + url.host;
})();

// ═══════════════════════════════════════════════════
//  STATE
// ═══════════════════════════════════════════════════

let agents = [];
let tasks = [];
let streamEvents = [];
let metricsData = null;
let costData = null;
let timelineData = {};  // taskId → timeline

let selectedAgent = null;
let selectedTask = null;
let activeStreamFilter = 'all';
let pinnedNode = null;
let statusFilter = null;
let currentView = 'mission';
let agentDetailAgent = null;
let activeDetailTab = 'tasks';
let pipelineCache = {};  // agentId → pipeline data
let lastEventTimestamp = null;

// Connection state
let ws = null;
let wsRetryCount = 0;
let wsMaxRetries = 3;
let pollTimer = null;
let isConnected = false;

// ═══════════════════════════════════════════════════
//  CONSTANTS
// ═══════════════════════════════════════════════════

const statusSort = { stuck: 0, error: 1, waiting_approval: 2, processing: 3, idle: 4 };
const statusLabel = { processing: 'Processing', stuck: 'Stuck', error: 'Error', idle: 'Idle', waiting_approval: 'Waiting', completed: 'Completed' };
const statusBadge = { processing: 'badge-processing', stuck: 'badge-stuck', error: 'badge-error', idle: 'badge-idle', waiting_approval: 'badge-waiting', completed: 'badge-completed' };
const statusColor = { completed: 'var(--success)', processing: 'var(--active)', failed: 'var(--error)', stuck: 'var(--stuck)', waiting: 'var(--warning)', escalated: 'var(--warning)' };
const typeColor = { system: 'var(--idle)', action: 'var(--active)', warning: 'var(--warning)', human: 'var(--success)', success: 'var(--success)', error: 'var(--error)', retry: 'var(--warning)', stuck: 'var(--stuck)', waiting: 'var(--warning)', llm: 'var(--llm)' };
const SEVERITY_COLOR = { debug: 'var(--idle)', info: 'var(--active)', warn: 'var(--warning)', error: 'var(--error)' };
const STREAM_FILTERS = ['all', 'task', 'action', 'error', 'llm', 'pipeline', 'human'];
const KIND_ICON = { llm_call: '◆', queue_snapshot: '⊞', todo: '☐', issue: '⚑', scheduled: '⏲' };

// ═══════════════════════════════════════════════════
//  HELPERS
// ═══════════════════════════════════════════════════

function hbClass(seconds) { if (seconds == null) return 'hb-dead'; return seconds < 60 ? 'hb-fresh' : seconds < 300 ? 'hb-stale' : 'hb-dead'; }
function hbText(seconds) { if (seconds == null) return 'unknown'; return seconds < 60 ? seconds + 's ago' : Math.floor(seconds / 60) + 'm ago'; }
function fmtTokens(n) { if (n == null) return '—'; return n >= 1000 ? (n / 1000).toFixed(1) + 'K' : String(n); }
function fmtDuration(ms) { if (ms == null) return '—'; if (ms < 1000) return ms + 'ms'; if (ms < 60000) return (ms / 1000).toFixed(1) + 's'; return Math.floor(ms / 60000) + 'm' + Math.round((ms % 60000) / 1000) + 's'; }
function fmtCost(c) { if (c == null) return '—'; return '$' + c.toFixed(2); }
function timeAgo(ts) {
  if (!ts) return '—';
  const diff = Math.floor((Date.now() - new Date(ts).getTime()) / 1000);
  if (diff < 5) return 'just now';
  if (diff < 60) return diff + 's ago';
  if (diff < 3600) return Math.floor(diff / 60) + 'm ago';
  return Math.floor(diff / 3600) + 'h ago';
}
function escHtml(s) { const d = document.createElement('div'); d.textContent = s; return d.innerHTML; }

// ═══════════════════════════════════════════════════
//  C2.5.1 — API CLIENT MODULE
// ═══════════════════════════════════════════════════

async function apiFetch(path, params = {}) {
  const url = new URL(CONFIG.endpoint + path);
  Object.entries(params).forEach(([k, v]) => { if (v != null) url.searchParams.set(k, v); });
  try {
    const resp = await fetch(url.toString(), {
      headers: { 'Authorization': 'Bearer ' + CONFIG.apiKey },
    });
    if (!resp.ok) throw new Error('HTTP ' + resp.status);
    return await resp.json();
  } catch (err) {
    console.warn('API fetch failed:', path, err.message);
    showToast('API error: ' + err.message, 'error');
    return null;
  }
}

async function fetchAgents() {
  const env = document.getElementById('envSelector').value;
  const data = await apiFetch('/v1/agents', { environment: env, sort: 'attention', limit: 100 });
  if (data && data.data) {
    agents = data.data.map(a => ({
      id: a.agent_id,
      type: a.agent_type || 'general',
      status: a.derived_status || 'idle',
      task: a.current_task_id,
      hb: a.heartbeat_age_seconds,
      sparkline: a.sparkline_1h || [0,0,0,0,0,0,0,0,0,0,0,0],
      queueDepth: (a.stats_1h && a.stats_1h.queue_depth) || 0,
      activeIssues: (a.stats_1h && a.stats_1h.active_issues) || 0,
      processingSummary: a.processing_summary || null,
      version: a.agent_version,
      framework: a.framework,
      stats: a.stats_1h || {},
    }));
  }
}

async function fetchTasks(agentId) {
  const params = { limit: 20, sort: 'newest' };
  if (agentId) params.agent_id = agentId;
  const env = document.getElementById('envSelector').value;
  params.environment = env;
  const data = await apiFetch('/v1/tasks', params);
  if (data && data.data) {
    tasks = data.data.map(t => ({
      id: t.task_id,
      agent: t.agent_id,
      type: t.task_type || '—',
      status: t.derived_status || 'processing',
      duration: fmtDuration(t.duration_ms),
      durationMs: t.duration_ms,
      cost: fmtCost(t.total_cost),
      llmCalls: t.llm_call_count || 0,
      time: timeAgo(t.started_at),
      startedAt: t.started_at,
      taskRunId: t.task_run_id,
    }));
  }
}

async function fetchTimeline(taskId) {
  if (!taskId) return;
  const data = await apiFetch('/v1/tasks/' + encodeURIComponent(taskId) + '/timeline');
  if (data) timelineData[taskId] = data;
}

async function fetchEvents(filters = {}) {
  const params = { limit: CONFIG.maxStreamEvents, exclude_heartbeats: true };
  if (filters.agent_id) params.agent_id = filters.agent_id;
  if (filters.since) params.since = filters.since;
  const env = document.getElementById('envSelector').value;
  params.environment = env;
  const data = await apiFetch('/v1/events', params);
  if (data && data.data) {
    const newEvents = data.data.map(e => ({
      eventId: e.event_id,
      type: e.event_type,
      kind: e.payload && e.payload.kind ? e.payload.kind : null,
      agent: e.agent_id,
      task: e.task_id,
      summary: (e.payload && e.payload.summary) ? e.payload.summary : e.event_type,
      time: timeAgo(e.timestamp),
      timestamp: e.timestamp,
      severity: e.severity || 'info',
    }));
    if (filters.since) {
      // Merge new events (prepend), deduplicate by eventId
      const existingIds = new Set(streamEvents.map(e => e.eventId));
      const truly = newEvents.filter(e => !existingIds.has(e.eventId));
      streamEvents = [...truly, ...streamEvents].slice(0, CONFIG.maxStreamEvents);
    } else {
      streamEvents = newEvents;
    }
    if (streamEvents.length > 0) {
      lastEventTimestamp = streamEvents[0].timestamp;
    }
  }
}

async function fetchMetrics() {
  const env = document.getElementById('envSelector').value;
  const data = await apiFetch('/v1/metrics', { range: '1h', environment: env });
  if (data) metricsData = data;
}

async function fetchCost() {
  const env = document.getElementById('envSelector').value;
  // Fetch by model and by agent
  const [byModel, byAgent] = await Promise.all([
    apiFetch('/v1/metrics', { range: '1h', group_by: 'model', environment: env }),
    apiFetch('/v1/cost', { group_by: 'agent', environment: env }),
  ]);
  costData = { byModel, byAgent };
}

async function fetchPipeline(agentId) {
  const data = await apiFetch('/v1/agents/' + encodeURIComponent(agentId) + '/pipeline');
  if (data) pipelineCache[agentId] = data;
}

// ═══════════════════════════════════════════════════
//  RENDERING — HIVE (C2.2)
// ═══════════════════════════════════════════════════

function renderHive() {
  const list = document.getElementById('hiveList');
  let agentList = [...agents].sort((a, b) => (statusSort[a.status] ?? 5) - (statusSort[b.status] ?? 5));
  if (statusFilter) agentList = agentList.filter(a => a.status === statusFilter);
  document.getElementById('agentCount').textContent = agentList.length + ' agent' + (agentList.length !== 1 ? 's' : '');

  const needsAttention = agents.filter(a => a.status === 'stuck' || a.status === 'error').length;
  const badge = document.getElementById('attentionBadge');
  if (needsAttention > 0) { badge.style.display = 'inline'; badge.textContent = needsAttention + ' ⚠'; }
  else badge.style.display = 'none';

  if (agentList.length === 0) {
    list.innerHTML = '<div class="empty-state"><span class="empty-state-icon">⬡</span>No agents match filter</div>';
    return;
  }

  list.innerHTML = agentList.map(a => {
    const maxSpark = Math.max(...a.sparkline, 1);
    const isUrgent = a.status === 'stuck' || a.status === 'error';
    const isSelected = (currentView === 'agentDetail' && agentDetailAgent === a.id) || a.id === selectedAgent;

    let pipelineHtml = '';
    const badges = [];
    if (a.queueDepth > 0) badges.push('<span class="queue-badge ' + (a.queueDepth > 5 ? 'high' : '') + '">Q:' + a.queueDepth + '</span>');
    if (a.activeIssues > 0) badges.push('<span class="issue-indicator"><span class="issue-dot"></span>' + a.activeIssues + ' issue' + (a.activeIssues > 1 ? 's' : '') + '</span>');
    if (a.processingSummary) badges.push('<span class="processing-line">↳ ' + escHtml(a.processingSummary) + '</span>');
    if (badges.length > 0) pipelineHtml = '<div class="agent-card-pipeline">' + badges.join('') + '</div>';

    return '<div class="agent-card fade-in ' + (isSelected ? 'selected' : '') + ' ' + (isUrgent ? 'urgency-glow' : '') + '"' +
      ' onclick="selectAgent(\'' + a.id + '\')" ondblclick="openAgentDetail(\'' + a.id + '\')" data-agent="' + a.id + '">' +
      '<div class="agent-card-top">' +
        '<div class="agent-name">' + escHtml(a.id) + '</div>' +
        '<div class="agent-status-badge ' + (statusBadge[a.status] || 'badge-idle') + '">' + (statusLabel[a.status] || a.status) + '</div>' +
      '</div>' +
      '<div class="agent-card-meta">' +
        '<div class="agent-type-label">' + escHtml(a.type) + '</div>' +
        '<div class="heartbeat-indicator"><div class="hb-dot ' + hbClass(a.hb) + '"></div>' + hbText(a.hb) + '</div>' +
      '</div>' +
      pipelineHtml +
      (a.task ? '<div class="agent-task-info"><span style="opacity:0.5">↳</span> <span class="clickable-entity" onclick="event.stopPropagation(); selectTask(\'' + a.task + '\')">' + escHtml(a.task) + '</span></div>' : '') +
      '<div class="sparkline-row">' + a.sparkline.map(v => '<div class="spark-bar" style="height: ' + ((v / maxSpark) * 18 + 2) + 'px; background: ' + (isUrgent ? 'var(--error)' : 'var(--active)') + '"></div>').join('') + '</div>' +
    '</div>';
  }).join('');
}

// ═══════════════════════════════════════════════════
//  RENDERING — SUMMARY + METRICS (C2.3.1a-b)
// ═══════════════════════════════════════════════════

function renderSummary() {
  const processing = agents.filter(a => a.status === 'processing').length;
  const stuck = agents.filter(a => a.status === 'stuck').length;
  const waiting = agents.filter(a => a.status === 'waiting_approval').length;
  const errors = agents.filter(a => a.status === 'error').length;
  const sf = statusFilter;
  const summary = metricsData && metricsData.summary ? metricsData.summary : {};
  const successRate = summary.success_rate != null ? Math.round(summary.success_rate) + '%' : '—';
  const avgDur = summary.avg_duration_ms != null ? fmtDuration(summary.avg_duration_ms) : '—';
  const totalCost = summary.total_cost != null ? '$' + summary.total_cost.toFixed(2) : '—';

  document.getElementById('summaryBar').innerHTML =
    '<div class="summary-stat"><div class="stat-label">Total Agents</div><div class="stat-value">' + agents.length + '</div></div>' +
    '<div class="summary-stat clickable ' + (sf === 'processing' ? 'active-filter-stat' : '') + '" onclick="toggleStatusFilter(\'processing\')"><div class="stat-label">Processing</div><div class="stat-value blue">' + processing + '</div></div>' +
    '<div class="summary-stat clickable ' + (sf === 'waiting_approval' ? 'active-filter-stat' : '') + '" onclick="toggleStatusFilter(\'waiting_approval\')"><div class="stat-label">Waiting</div><div class="stat-value amber">' + waiting + '</div></div>' +
    '<div class="summary-stat clickable ' + (sf === 'stuck' ? 'active-filter-stat' : '') + '" onclick="toggleStatusFilter(\'stuck\')"><div class="stat-label">Stuck</div><div class="stat-value red">' + stuck + '</div></div>' +
    '<div class="summary-stat clickable ' + (sf === 'error' ? 'active-filter-stat' : '') + '" onclick="toggleStatusFilter(\'error\')"><div class="stat-label">Errors</div><div class="stat-value red">' + errors + '</div></div>' +
    '<div class="summary-stat"><div class="stat-label">Success Rate (1h)</div><div class="stat-value green">' + successRate + '</div></div>' +
    '<div class="summary-stat"><div class="stat-label">Avg Duration</div><div class="stat-value">' + avgDur + '</div></div>' +
    '<div class="summary-stat"><div class="stat-label">Cost (1h)</div><div class="stat-value purple">' + totalCost + '</div></div>';
}

function renderMetrics() {
  const ts = metricsData && metricsData.timeseries ? metricsData.timeseries : [];
  const metrics = [
    { label: 'Throughput (1h)', key: 'throughput', color: 'var(--active)' },
    { label: 'Success Rate', key: 'success_rate_pct', color: 'var(--success)', max: 100 },
    { label: 'Errors', key: 'error_count', color: 'var(--error)' },
    { label: 'LLM Cost/Task', key: 'cost', color: 'var(--llm)' },
  ];

  document.getElementById('metricsRow').innerHTML = metrics.map(m => {
    let data;
    if (m.key === 'success_rate_pct') {
      data = ts.map(p => {
        const c = p.tasks_completed || 0;
        const f = p.tasks_failed || 0;
        return c + f > 0 ? Math.round(c / (c + f) * 100) : 100;
      });
    } else {
      data = ts.map(p => p[m.key] || 0);
    }
    if (data.length === 0) data = [0,0,0,0,0,0,0,0];
    // Take last 16 points
    data = data.slice(-16);
    const mx = m.max || Math.max(...data, 1);
    return '<div class="metric-cell"><div class="stat-label">' + m.label + '</div><div class="metric-chart">' +
      data.map(v => '<div class="metric-bar" style="height: ' + ((v / mx) * 22 + 2) + 'px; background: ' + m.color + '; opacity: 0.6;"></div>').join('') +
    '</div></div>';
  }).join('');
}

// ═══════════════════════════════════════════════════
//  RENDERING — TIMELINE (C2.3.1d-h)
// ═══════════════════════════════════════════════════

function getTimelineNodes(taskId) {
  const tl = timelineData[taskId];
  if (!tl || !tl.events) return { plan: null, nodes: [] };

  // Convert API events to render nodes
  const nodes = tl.events.map(e => {
    const payload = e.payload || {};
    const kind = payload.kind;
    let nodeType = 'system';
    if (e.event_type === 'task_started') nodeType = 'system';
    else if (e.event_type === 'task_completed') nodeType = 'success';
    else if (e.event_type === 'task_failed') nodeType = 'error';
    else if (e.event_type === 'action_started' || e.event_type === 'action_completed') nodeType = 'action';
    else if (e.event_type === 'action_failed') nodeType = 'error';
    else if (e.event_type === 'escalated') nodeType = 'warning';
    else if (e.event_type === 'approval_requested' || e.event_type === 'approval_received') nodeType = 'human';
    else if (e.event_type === 'retry_started') nodeType = 'retry';
    else if (kind === 'llm_call') nodeType = 'llm';

    const label = payload.action_name || payload.summary || e.event_type;
    const time = e.timestamp ? e.timestamp.split('T')[1].substring(0, 12) : '—';
    const dur = e.duration_ms != null ? fmtDuration(e.duration_ms) : '—';
    const detail = { event: e.event_type, ...(payload.data || {}) };
    const tags = payload.tags || [];
    const llmModel = kind === 'llm_call' && payload.data ? payload.data.model : null;
    const isRetry = e.event_type === 'retry_started';

    return { label, time, type: nodeType, dur, detail, tags, llmModel, isLlm: nodeType === 'llm', isBranch: isRetry };
  });

  // Build plan data
  let plan = null;
  if (tl.plan && tl.plan.steps) {
    plan = {
      steps: tl.plan.steps.map(s => ({
        desc: s.description,
        status: s.action === 'completed' ? 'completed' : s.action === 'failed' ? 'failed' : s.started_at ? 'active' : 'pending',
      })),
    };
  }

  return { plan, nodes };
}

function renderPlanBar() {
  const planBar = document.getElementById('planBar');
  const { plan } = getTimelineNodes(selectedTask);
  if (!plan) { planBar.classList.remove('visible'); return; }

  const completed = plan.steps.filter(s => s.status === 'completed').length;
  const total = plan.steps.length;
  document.getElementById('planLabel').textContent = 'Plan · ' + total + ' steps';
  document.getElementById('planProgress').textContent = completed + '/' + total + ' completed';
  document.getElementById('planSteps').innerHTML = plan.steps.map(s =>
    '<div class="plan-step ' + s.status + '"><div class="plan-step-tooltip">' + escHtml(s.desc) + '</div></div>'
  ).join('');
  planBar.classList.add('visible');
}

function renderTimeline() {
  const canvas = document.getElementById('timelineCanvas');
  const { nodes } = getTimelineNodes(selectedTask);
  pinnedNode = null;
  document.getElementById('pinnedDetail').classList.remove('visible');
  renderPlanBar();

  if (nodes.length === 0) {
    canvas.innerHTML = '<div class="empty-state"><span class="empty-state-icon">⏳</span>No timeline data</div>';
    return;
  }

  const mainNodes = nodes.filter(n => !n.isBranch);
  const branchNodes = nodes.filter(n => n.isBranch);

  let html = '<div class="timeline-track">';
  mainNodes.forEach((node, i) => {
    const color = typeColor[node.type] || 'var(--idle)';
    const filled = node.type === 'success' || node.type === 'error' || node.type === 'stuck';
    const isLlm = node.isLlm;
    const nodeIdx = nodes.indexOf(node);

    html += '<div class="tl-node ' + (isLlm ? 'llm-node' : '') + '" data-idx="' + nodeIdx + '" onclick="pinNode(' + nodeIdx + ')">';
    if (isLlm && node.llmModel) html += '<div class="tl-llm-badge">' + escHtml(node.llmModel) + '</div>';
    html += '<div class="tl-node-label" style="color: ' + color + '">' + escHtml(node.label) + '</div>';
    html += '<div class="tl-node-dot" style="border-color: ' + color + '; ' + (filled ? 'background: ' + color : '') + '"></div>';
    html += '<div class="tl-node-time">' + node.time + '</div></div>';

    if (i < mainNodes.length - 1) {
      const nextNode = mainNodes[i + 1];
      const widthMul = nextNode.dur && nextNode.dur !== '—' ? parseFloat(nextNode.dur) : 0.5;
      const w = Math.max(50, (isNaN(widthMul) ? 0.5 : widthMul) * 28 + 50);
      const nextColor = typeColor[nextNode.type] || 'var(--idle)';
      html += '<div class="tl-connector" style="width: ' + w + 'px;">';
      html += '<div class="tl-connector-line" style="background: linear-gradient(to right, ' + color + ', ' + nextColor + '); opacity: 0.4;"></div>';
      if (nextNode.dur && nextNode.dur !== '—') html += '<div class="tl-connector-duration">' + nextNode.dur + '</div>';
      html += '</div>';
    }
  });
  html += '</div>';
  canvas.innerHTML = html;
}

function pinNode(idx) {
  const { nodes } = getTimelineNodes(selectedTask);
  const node = nodes[idx];
  if (!node) return;
  if (pinnedNode === idx) { unpinDetail(); return; }
  pinnedNode = idx;

  document.querySelectorAll('.tl-node').forEach(el => el.classList.remove('pinned'));
  const el = document.querySelector('.tl-node[data-idx="' + idx + '"]');
  if (el) el.classList.add('pinned');

  const color = typeColor[node.type] || 'var(--idle)';
  document.getElementById('pinnedTitle').innerHTML = '<span style="color: ' + color + '">●</span> ' + escHtml(node.label) + ' <span style="color: var(--text-muted); font-weight: 400; font-size: 10px; margin-left: 8px">' + node.time + '</span>';

  let bodyHtml = '<div class="detail-col">';
  Object.entries(node.detail).forEach(([k, v]) => { bodyHtml += '<div class="detail-row"><span class="detail-key">' + escHtml(k) + '</span><span class="detail-val">' + escHtml(String(v)) + '</span></div>'; });
  bodyHtml += '</div>';
  if (node.dur && node.dur !== '—') bodyHtml += '<div class="detail-col"><div class="detail-row"><span class="detail-key">duration</span><span class="detail-val">' + node.dur + '</span></div></div>';
  if (node.tags && node.tags.length) bodyHtml += '<div class="detail-col" style="flex-basis: 100%;"><div style="margin-top: 2px;">' + node.tags.map(t => '<span class="detail-payload-tag">' + escHtml(t) + '</span>').join('') + '</div></div>';

  document.getElementById('pinnedBody').innerHTML = bodyHtml;
  document.getElementById('pinnedDetail').classList.add('visible');
}

function unpinDetail() {
  pinnedNode = null;
  document.querySelectorAll('.tl-node').forEach(el => el.classList.remove('pinned'));
  document.getElementById('pinnedDetail').classList.remove('visible');
}

// ═══════════════════════════════════════════════════
//  RENDERING — TASKS TABLE (C2.3.1c)
// ═══════════════════════════════════════════════════

function renderTasks() {
  const body = document.getElementById('tasksBody');
  let taskList = tasks;
  if (selectedAgent) taskList = taskList.filter(t => t.agent === selectedAgent);

  if (taskList.length === 0) {
    body.innerHTML = '<tr><td colspan="8"><div class="empty-state"><span class="empty-state-icon">📋</span>No tasks</div></td></tr>';
    return;
  }

  body.innerHTML = taskList.map(t =>
    '<tr class="' + (t.id === selectedTask ? 'selected-row' : '') + '" onclick="selectTask(\'' + t.id + '\')">' +
      '<td><span class="clickable-entity" style="color: var(--accent); font-weight: 500;">' + escHtml(t.id) + '</span></td>' +
      '<td><span class="clickable-entity" onclick="event.stopPropagation(); selectAgent(\'' + t.agent + '\')">' + escHtml(t.agent) + '</span></td>' +
      '<td>' + escHtml(t.type) + '</td>' +
      '<td><span class="task-status-dot" style="background: ' + (statusColor[t.status] || 'var(--idle)') + '"></span>' + t.status + '</td>' +
      '<td class="task-duration">' + t.duration + '</td>' +
      '<td>' + (t.llmCalls > 0 ? '<span class="task-llm-badge">◆ ' + t.llmCalls + '</span>' : '—') + '</td>' +
      '<td>' + t.cost + '</td>' +
      '<td style="color: var(--text-muted)">' + t.time + '</td>' +
    '</tr>'
  ).join('');
}

// ═══════════════════════════════════════════════════
//  RENDERING — STREAM (C2.4)
// ═══════════════════════════════════════════════════

function renderStreamFilters() {
  document.getElementById('streamFilters').innerHTML = STREAM_FILTERS.map(f =>
    '<div class="filter-chip ' + (f === activeStreamFilter ? 'active' : '') + '" onclick="setStreamFilter(\'' + f + '\')">' + f + '</div>'
  ).join('');
}

function getFilteredStream() {
  let events = streamEvents;
  if (selectedAgent) events = events.filter(e => e.agent === selectedAgent);
  if (activeStreamFilter !== 'all') {
    events = events.filter(e => {
      if (activeStreamFilter === 'task') return e.type.startsWith('task_');
      if (activeStreamFilter === 'action') return e.type.startsWith('action_');
      if (activeStreamFilter === 'error') return e.severity === 'error';
      if (activeStreamFilter === 'llm') return e.kind === 'llm_call';
      if (activeStreamFilter === 'pipeline') return e.kind && ['queue_snapshot', 'todo', 'issue', 'scheduled'].includes(e.kind);
      if (activeStreamFilter === 'human') return e.type.startsWith('approval');
      return true;
    });
  }
  return events;
}

function renderStream() {
  const list = document.getElementById('streamList');
  const filtered = getFilteredStream();
  document.getElementById('eventCount').textContent = filtered.length + ' event' + (filtered.length !== 1 ? 's' : '');

  if (filtered.length === 0) {
    list.innerHTML = '<div class="empty-state" style="padding-top: 40px;"><span class="empty-state-icon">📡</span>No events match filters</div>';
    return;
  }

  list.innerHTML = filtered.map(e => {
    const kindIcon = e.kind ? (KIND_ICON[e.kind] || '') : '';
    const sevColor = SEVERITY_COLOR[e.severity] || 'var(--idle)';
    const kindColor = e.kind === 'llm_call' ? 'var(--llm)' : e.kind === 'issue' ? 'var(--error)' : sevColor;

    return '<div class="stream-event">' +
      '<div class="stream-event-top">' +
        '<div class="stream-event-type" style="color: ' + kindColor + '">' +
          '<div class="event-type-dot" style="background: ' + kindColor + '"></div>' +
          (kindIcon ? '<span class="event-kind-icon">' + kindIcon + '</span>' : '') + (e.kind || e.type) +
        '</div>' +
        '<div class="stream-event-time">' + e.time + '</div>' +
      '</div>' +
      '<div class="stream-event-body">' +
        '<div class="stream-event-agent">' +
          '<span class="clickable-entity" onclick="selectAgent(\'' + e.agent + '\')">' + escHtml(e.agent) + '</span>' +
          (e.task ? ' › <span class="clickable-entity" onclick="selectTask(\'' + e.task + '\')">' + escHtml(e.task) + '</span>' : '') +
        '</div>' +
        escHtml(e.summary) +
      '</div>' +
    '</div>';
  }).join('');
}

// ═══════════════════════════════════════════════════
//  RENDERING — AGENT DETAIL (C2.3.3)
// ═══════════════════════════════════════════════════

function renderAgentDetail() {
  if (!agentDetailAgent) return;
  const agent = agents.find(a => a.id === agentDetailAgent);
  if (!agent) return;

  document.getElementById('detailAgentName').textContent = agent.id;
  document.getElementById('detailAgentBadge').innerHTML = '<div class="agent-status-badge ' + (statusBadge[agent.status] || 'badge-idle') + '">' + (statusLabel[agent.status] || agent.status) + '</div>';

  // Tasks tab
  const agentTasks = tasks.filter(t => t.agent === agent.id);
  let tasksHtml = '<table class="pipeline-table"><thead><tr><th>Task ID</th><th>Type</th><th>Status</th><th>Duration</th><th>LLM</th><th>Cost</th><th>Time</th></tr></thead><tbody>';
  agentTasks.forEach(t => {
    tasksHtml += '<tr onclick="selectTask(\'' + t.id + '\')" style="cursor:pointer;">' +
      '<td style="color: var(--accent);">' + escHtml(t.id) + '</td><td>' + escHtml(t.type) + '</td>' +
      '<td><span class="task-status-dot" style="background: ' + (statusColor[t.status] || 'var(--idle)') + '"></span>' + t.status + '</td>' +
      '<td>' + t.duration + '</td><td>' + (t.llmCalls > 0 ? '<span class="task-llm-badge">◆ ' + t.llmCalls + '</span>' : '—') + '</td>' +
      '<td>' + t.cost + '</td><td style="color: var(--text-muted)">' + t.time + '</td></tr>';
  });
  tasksHtml += '</tbody></table>';
  document.getElementById('detailTabTasks').innerHTML = agentTasks.length > 0 ? tasksHtml : '<div class="pipeline-empty">No tasks for this agent</div>';

  // Pipeline tab
  const pl = pipelineCache[agent.id] || { queue: {}, todos: {}, scheduled: {} };
  let pHtml = '';

  // Issues (from agent stats or pipeline)
  const issues = pl.issues || [];
  if (issues.length > 0) {
    pHtml += '<div class="pipeline-section"><div class="pipeline-section-header"><div class="pipeline-section-title">Active Issues</div><div class="pipeline-badge" style="color: var(--error);">' + issues.length + '</div></div>';
    pHtml += '<table class="pipeline-table"><thead><tr><th>Issue</th><th>Severity</th><th>Category</th><th>Occurrences</th></tr></thead><tbody>';
    issues.forEach(iss => { pHtml += '<tr><td>' + escHtml(iss.summary || '') + '</td><td><span class="severity-badge severity-' + (iss.severity || 'medium') + '">' + (iss.severity || '—') + '</span></td><td>' + escHtml(iss.category || '—') + '</td><td>×' + (iss.occurrences || 1) + '</td></tr>'; });
    pHtml += '</tbody></table></div>';
  }

  // Queue
  const queueItems = (pl.queue && pl.queue.items) || [];
  const queueDepth = (pl.queue && pl.queue.depth) || queueItems.length;
  pHtml += '<div class="pipeline-section"><div class="pipeline-section-header"><div class="pipeline-section-title">Queue</div><div class="pipeline-badge">' + queueDepth + ' items</div></div>';
  if (queueItems.length > 0) {
    pHtml += '<table class="pipeline-table"><thead><tr><th>ID</th><th>Priority</th><th>Source</th><th>Summary</th></tr></thead><tbody>';
    queueItems.forEach(q => { pHtml += '<tr><td style="color: var(--text-muted)">' + escHtml(q.id || '') + '</td><td><span class="priority-badge priority-' + (q.priority || 'normal') + '">' + (q.priority || 'normal') + '</span></td><td>' + escHtml(q.source || '') + '</td><td>' + escHtml(q.summary || '') + '</td></tr>'; });
    pHtml += '</tbody></table>';
  } else { pHtml += '<div class="pipeline-empty">Queue is empty — agent is caught up</div>'; }
  pHtml += '</div>';

  // TODOs
  const todoItems = (pl.todos && pl.todos.items) || [];
  if (todoItems.length > 0) {
    pHtml += '<div class="pipeline-section"><div class="pipeline-section-header"><div class="pipeline-section-title">Active TODOs</div><div class="pipeline-badge">' + todoItems.length + '</div></div>';
    pHtml += '<table class="pipeline-table"><thead><tr><th>TODO</th><th>Priority</th><th>Source</th></tr></thead><tbody>';
    todoItems.forEach(td => { pHtml += '<tr><td>' + escHtml(td.summary || '') + '</td><td><span class="priority-badge priority-' + (td.priority || 'normal') + '">' + (td.priority || 'normal') + '</span></td><td>' + escHtml(td.source || '') + '</td></tr>'; });
    pHtml += '</tbody></table></div>';
  }

  // Scheduled
  const schedItems = (pl.scheduled && pl.scheduled.items) || [];
  if (schedItems.length > 0) {
    pHtml += '<div class="pipeline-section"><div class="pipeline-section-header"><div class="pipeline-section-title">Scheduled</div><div class="pipeline-badge">' + schedItems.length + '</div></div>';
    pHtml += '<table class="pipeline-table"><thead><tr><th>Name</th><th>Next Run</th><th>Interval</th><th>Status</th></tr></thead><tbody>';
    schedItems.forEach(s => {
      const stColor = s.last_status === 'success' || s.last_status === 'ok' ? 'var(--success)' : 'var(--warning)';
      pHtml += '<tr><td>' + escHtml(s.name || '') + '</td><td>' + (s.next_run || '—') + '</td><td>' + (s.interval || '—') + '</td><td style="color: ' + stColor + '">' + (s.last_status || '—') + '</td></tr>';
    });
    pHtml += '</tbody></table></div>';
  }

  if (!pHtml) pHtml = '<div class="pipeline-empty">No pipeline data for this agent</div>';
  document.getElementById('detailTabPipeline').innerHTML = pHtml;
}

// ═══════════════════════════════════════════════════
//  RENDERING — COST EXPLORER (C2.3.2)
// ═══════════════════════════════════════════════════

function renderCostExplorer() {
  if (!costData) return;
  const byAgent = costData.byAgent;
  const byModel = costData.byModel;

  // Totals from byAgent or byModel
  const totals = (byAgent && byAgent.totals) || (byModel && byModel.summary) || {};
  const totalCost = totals.cost || totals.total_cost || 0;
  const totalCalls = totals.call_count || totals.llm_call_count || 0;
  const totalIn = totals.tokens_in || totals.total_tokens_in || 0;
  const totalOut = totals.tokens_out || totals.total_tokens_out || 0;
  const avgCost = totalCalls > 0 ? totalCost / totalCalls : 0;

  document.getElementById('costRibbon').innerHTML =
    '<div class="cost-stat"><div class="stat-label">Total Cost</div><div class="stat-value purple">$' + totalCost.toFixed(2) + '</div></div>' +
    '<div class="cost-stat"><div class="stat-label">LLM Calls</div><div class="stat-value">' + totalCalls + '</div></div>' +
    '<div class="cost-stat"><div class="stat-label">Tokens In</div><div class="stat-value">' + fmtTokens(totalIn) + '</div></div>' +
    '<div class="cost-stat"><div class="stat-label">Tokens Out</div><div class="stat-value">' + fmtTokens(totalOut) + '</div></div>' +
    '<div class="cost-stat"><div class="stat-label">Avg Cost/Call</div><div class="stat-value">$' + avgCost.toFixed(3) + '</div></div>';

  let html = '';

  // By Model
  const modelGroups = (byModel && byModel.groups) || [];
  if (modelGroups.length > 0) {
    const maxModelCost = Math.max(...modelGroups.map(m => m.cost || 0), 0.01);
    html += '<div><div class="cost-section-title">Cost by Model</div><table class="cost-table"><thead><tr><th>Model</th><th>Calls</th><th>Tokens In</th><th>Tokens Out</th><th>Cost</th><th></th></tr></thead><tbody>';
    modelGroups.forEach(m => {
      html += '<tr><td><span class="model-badge">' + escHtml(m.model || '—') + '</span></td><td>' + (m.call_count || 0) + '</td><td>' + fmtTokens(m.tokens_in) + '</td><td>' + fmtTokens(m.tokens_out) + '</td><td style="color: var(--llm); font-weight: 600;">$' + (m.cost || 0).toFixed(2) + '</td><td style="width: 100px;"><div class="cost-bar" style="width: ' + ((m.cost || 0) / maxModelCost * 100) + '%"></div></td></tr>';
    });
    html += '</tbody></table></div>';
  }

  // By Agent
  const agentGroups = (byAgent && byAgent.groups) || [];
  if (agentGroups.length > 0) {
    const sortedAgents = [...agentGroups].sort((a, b) => (b.cost || 0) - (a.cost || 0));
    const maxAgentCost = Math.max(...sortedAgents.map(a => a.cost || 0), 0.01);
    html += '<div><div class="cost-section-title">Cost by Agent</div><table class="cost-table"><thead><tr><th>Agent</th><th>Calls</th><th>Tokens In</th><th>Tokens Out</th><th>Cost</th><th></th></tr></thead><tbody>';
    sortedAgents.forEach(a => {
      const agentId = a.agent_id || a.agent || '—';
      html += '<tr><td><span class="clickable-entity" onclick="openAgentDetail(\'' + agentId + '\')" style="color: var(--accent);">' + escHtml(agentId) + '</span></td><td>' + (a.call_count || 0) + '</td><td>' + fmtTokens(a.tokens_in) + '</td><td>' + fmtTokens(a.tokens_out) + '</td><td style="color: var(--llm); font-weight: 600;">$' + (a.cost || 0).toFixed(2) + '</td><td style="width: 100px;"><div class="cost-bar" style="width: ' + ((a.cost || 0) / maxAgentCost * 100) + '%"></div></td></tr>';
    });
    html += '</tbody></table></div>';
  }

  document.getElementById('costTables').innerHTML = html || '<div class="empty-state">No cost data available</div>';
}

// ═══════════════════════════════════════════════════
//  NAVIGATION
// ═══════════════════════════════════════════════════

function switchView(view) {
  currentView = view;
  document.querySelectorAll('.view-tab').forEach(t => t.classList.remove('active'));
  document.querySelectorAll('.center-view').forEach(v => v.classList.remove('active'));

  if (view === 'mission') {
    document.querySelector('.view-tab:nth-child(1)').classList.add('active');
    document.getElementById('viewMission').classList.add('active');
  } else if (view === 'cost') {
    document.querySelector('.view-tab:nth-child(2)').classList.add('active');
    document.getElementById('viewCost').classList.add('active');
    fetchCost().then(renderCostExplorer);
  } else if (view === 'agentDetail') {
    document.querySelectorAll('.view-tab').forEach(t => t.classList.remove('active'));
    document.getElementById('viewAgentDetail').classList.add('active');
    renderAgentDetail();
  }
  renderHive();
}

async function openAgentDetail(agentId) {
  agentDetailAgent = agentId;
  selectedAgent = agentId;
  activeDetailTab = 'tasks';
  await fetchPipeline(agentId);
  switchView('agentDetail');
  switchDetailTab('tasks');
  renderStream();
  updateFilterBar();
}

function closeAgentDetail() {
  agentDetailAgent = null;
  selectedAgent = null;
  switchView('mission');
  renderTasks();
  renderStream();
  updateFilterBar();
}

function switchDetailTab(tab) {
  activeDetailTab = tab;
  document.querySelectorAll('.detail-tab').forEach(t => t.classList.remove('active'));
  document.querySelectorAll('.detail-tab-content').forEach(c => c.classList.remove('active'));
  const tabs = document.querySelectorAll('.detail-tab');
  const contents = document.querySelectorAll('.detail-tab-content');
  if (tab === 'tasks') { tabs[0].classList.add('active'); contents[0].classList.add('active'); }
  else if (tab === 'pipeline') { tabs[1].classList.add('active'); contents[1].classList.add('active'); }
}

// ═══════════════════════════════════════════════════
//  INTERACTIONS
// ═══════════════════════════════════════════════════

function selectAgent(agentId) {
  if (currentView === 'agentDetail') {
    if (agentDetailAgent === agentId) { closeAgentDetail(); return; }
    openAgentDetail(agentId);
    return;
  }

  if (selectedAgent === agentId) { selectedAgent = null; }
  else {
    selectedAgent = agentId;
    statusFilter = null;
    const agent = agents.find(a => a.id === agentId);
    if (agent && agent.task) {
      selectedTask = agent.task;
      updateTimelineHeader();
      fetchTimeline(selectedTask).then(renderTimeline);
    }
  }
  updateFilterBar();
  renderHive();
  renderSummary();
  renderTasks();
  renderStream();
}

async function selectTask(taskId) {
  if (currentView === 'agentDetail') switchView('mission');
  selectedTask = taskId;
  updateTimelineHeader();
  renderTasks();
  await fetchTimeline(taskId);
  renderTimeline();
}

function updateTimelineHeader() {
  const task = tasks.find(t => t.id === selectedTask);
  if (task) {
    document.getElementById('tlTaskId').textContent = selectedTask;
    const statusChar = task.status === 'completed' ? '✓' : task.status === 'failed' ? '✗' : task.status === 'stuck' ? '⚠' : '◉';
    const statusClr = statusColor[task.status] || 'var(--text-muted)';
    document.getElementById('tlMeta').innerHTML =
      '<span>⏱ ' + task.duration + '</span>' +
      ' <span class="clickable-entity" onclick="selectAgent(\'' + task.agent + '\')">🤖 ' + escHtml(task.agent) + '</span>' +
      ' <span style="color: ' + statusClr + ';">' + statusChar + ' ' + task.status + '</span>' +
      (task.llmCalls > 0 ? ' <span style="color: var(--llm);">◆ ' + task.llmCalls + ' LLM</span>' : '');
  }
}

function toggleStatusFilter(status) {
  if (statusFilter === status) statusFilter = null;
  else { statusFilter = status; selectedAgent = null; }
  updateFilterBar();
  renderHive();
  renderSummary();
  renderTasks();
  renderStream();
}

function clearGlobalFilter() {
  selectedAgent = null;
  statusFilter = null;
  if (currentView === 'agentDetail') closeAgentDetail();
  updateFilterBar();
  renderHive();
  renderSummary();
  renderTasks();
  renderStream();
}

function setStreamFilter(f) { activeStreamFilter = f; renderStreamFilters(); renderStream(); }

function copyPermalink() {
  const btn = document.querySelector('.permalink-btn');
  btn.textContent = '✓ Copied!';
  if (selectedTask) {
    const url = window.location.origin + window.location.pathname + '?task=' + encodeURIComponent(selectedTask);
    navigator.clipboard.writeText(url).catch(() => {});
  }
  setTimeout(() => { btn.textContent = '⧉ Permalink'; }, 1500);
}

function updateFilterBar() {
  const bar = document.getElementById('filterBar');
  const layout = document.getElementById('mainLayout');
  const hasAgentFilter = selectedAgent !== null;
  const hasStatusFilter = statusFilter !== null;
  const hasAnyFilter = hasAgentFilter || hasStatusFilter;

  if (hasAnyFilter) {
    let parts = [];
    if (hasAgentFilter) parts.push('agent = ' + selectedAgent);
    if (hasStatusFilter) parts.push('status = ' + statusFilter);
    document.getElementById('filterPillText').textContent = '⬡ Filtering: ' + parts.join('  ·  ');
    bar.classList.add('visible');
    layout.classList.add('has-filter');
  } else {
    bar.classList.remove('visible');
    layout.classList.remove('has-filter');
  }
}

function onEnvChange() {
  // Reload all data when environment changes
  initialLoad();
}

// ═══════════════════════════════════════════════════
//  TOAST NOTIFICATIONS
// ═══════════════════════════════════════════════════

function showToast(msg, type = 'info') {
  const container = document.getElementById('toastContainer');
  const toast = document.createElement('div');
  toast.className = 'toast' + (type === 'error' ? ' error' : '');
  toast.textContent = msg;
  container.appendChild(toast);
  setTimeout(() => { toast.remove(); }, 4000);
}

// ═══════════════════════════════════════════════════
//  C2.5.3 — WEBSOCKET CONNECTION
// ═══════════════════════════════════════════════════

function connectWebSocket() {
  if (ws && (ws.readyState === WebSocket.OPEN || ws.readyState === WebSocket.CONNECTING)) return;

  try {
    const wsUrl = CONFIG.wsEndpoint + '/v1/stream?token=' + encodeURIComponent(CONFIG.apiKey);
    ws = new WebSocket(wsUrl);

    ws.onopen = function() {
      wsRetryCount = 0;
      setConnectionStatus(true);
      // Subscribe to events and agents channels
      ws.send(JSON.stringify({
        action: 'subscribe',
        channels: ['events', 'agents'],
        filters: {
          environment: document.getElementById('envSelector').value,
          min_severity: 'info',
        },
      }));
    };

    ws.onmessage = function(evt) {
      try {
        const msg = JSON.parse(evt.data);
        handleWsMessage(msg);
      } catch (e) { /* ignore parse errors */ }
    };

    ws.onclose = function() {
      setConnectionStatus(false);
      ws = null;
      wsRetryCount++;
      if (wsRetryCount <= wsMaxRetries) {
        const delay = Math.min(1000 * Math.pow(2, wsRetryCount), 16000);
        setTimeout(connectWebSocket, delay);
      } else {
        // C2.5.5 — Fall back to polling
        startPolling();
      }
    };

    ws.onerror = function() {
      // onclose will handle retry logic
    };
  } catch (e) {
    setConnectionStatus(false);
    startPolling();
  }
}

// C2.5.4 — Live event handling
function handleWsMessage(msg) {
  if (msg.type === 'event.new') {
    const e = msg.data || msg.event || msg;
    const payload = e.payload || {};
    const newEvent = {
      eventId: e.event_id,
      type: e.event_type,
      kind: payload.kind || null,
      agent: e.agent_id,
      task: e.task_id,
      summary: payload.summary || e.event_type,
      time: 'just now',
      timestamp: e.timestamp,
      severity: e.severity || 'info',
    };
    // Prepend and deduplicate
    if (!streamEvents.find(ev => ev.eventId === newEvent.eventId)) {
      streamEvents.unshift(newEvent);
      if (streamEvents.length > CONFIG.maxStreamEvents) streamEvents.pop();
      lastEventTimestamp = newEvent.timestamp;
      renderStream();
    }
    // Refresh task table if affected task is visible
    if (newEvent.task === selectedTask) {
      fetchTimeline(selectedTask).then(renderTimeline);
    }
  } else if (msg.type === 'agent.status_changed' || msg.type === 'agent.stuck' || msg.type === 'agent.heartbeat') {
    // Refresh agents
    fetchAgents().then(() => { renderHive(); renderSummary(); });
  } else if (msg.type === 'pong' || msg.type === 'subscribed') {
    // no-op
  }
}

// C2.5.5 — Polling fallback
function startPolling() {
  if (pollTimer) return;
  setConnectionStatus(false, 'Polling');
  pollTimer = setInterval(async () => {
    await fetchAgents();
    await fetchEvents(lastEventTimestamp ? { since: lastEventTimestamp } : {});
    renderHive();
    renderSummary();
    renderStream();
    // Update event times
    streamEvents.forEach(e => { e.time = timeAgo(e.timestamp); });
  }, CONFIG.pollInterval);
}

function stopPolling() {
  if (pollTimer) { clearInterval(pollTimer); pollTimer = null; }
}

function setConnectionStatus(connected, label) {
  isConnected = connected;
  const dot = document.getElementById('connectionDot');
  const text = document.getElementById('connectionText');
  if (connected) {
    dot.classList.remove('disconnected');
    text.textContent = 'Connected';
  } else {
    dot.classList.add('disconnected');
    text.textContent = label || 'Disconnected';
  }
}

// C2.5.6 — Filter sync
function syncWsFilters() {
  if (ws && ws.readyState === WebSocket.OPEN) {
    ws.send(JSON.stringify({
      action: 'subscribe',
      channels: ['events', 'agents'],
      filters: {
        environment: document.getElementById('envSelector').value,
        agent_id: selectedAgent,
        min_severity: 'info',
      },
    }));
  }
}

// ═══════════════════════════════════════════════════
//  C2.5.2 — INITIAL DATA LOAD
// ═══════════════════════════════════════════════════

async function initialLoad() {
  // Parallel fetch of all initial data
  await Promise.all([
    fetchAgents(),
    fetchTasks(),
    fetchEvents(),
    fetchMetrics(),
  ]);

  // Render all views
  renderHive();
  renderSummary();
  renderMetrics();
  renderTasks();
  renderStreamFilters();
  renderStream();
  updateFilterBar();

  // Auto-select first task if none selected
  if (!selectedTask && tasks.length > 0) {
    selectedTask = tasks[0].id;
    updateTimelineHeader();
    await fetchTimeline(selectedTask);
    renderTimeline();
  }

  // Set workspace badge based on agents
  if (agents.length > 0 && agents[0].stats && agents[0].stats.group) {
    document.getElementById('workspaceBadge').textContent = agents[0].stats.group;
  } else {
    document.getElementById('workspaceBadge').textContent = document.getElementById('envSelector').value;
  }
}

// ═══════════════════════════════════════════════════
//  PERIODIC REFRESH (update time labels, refresh data)
// ═══════════════════════════════════════════════════

setInterval(() => {
  // Refresh time labels
  streamEvents.forEach(e => { e.time = timeAgo(e.timestamp); });
  tasks.forEach(t => { t.time = timeAgo(t.startedAt); });
  renderStream();

  // Periodic data refresh every 30s
}, 10000);

setInterval(async () => {
  await fetchAgents();
  await fetchMetrics();
  renderHive();
  renderSummary();
  renderMetrics();
}, 30000);

// ═══════════════════════════════════════════════════
//  INIT
// ═══════════════════════════════════════════════════

(async function init() {
  // Check for task in URL
  const urlParams = new URLSearchParams(window.location.search);
  if (urlParams.has('task')) selectedTask = urlParams.get('task');

  setConnectionStatus(false, 'Connecting…');

  await initialLoad();

  // Try WebSocket, fall back to polling
  connectWebSocket();

  // If WS doesn't connect within 5s, start polling as backup
  setTimeout(() => {
    if (!isConnected && !pollTimer) startPolling();
  }, 5000);
})();
</script>
</body>
</html>
