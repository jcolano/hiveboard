<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Operational Events — HiveBoard Docs</title>
<link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;500;600;700&family=Plus+Jakarta+Sans:wght@400;500;600;700;800&display=swap" rel="stylesheet">
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet">
<style>
/* ═══════════════════════════════════════
   DESIGN TOKENS (HiveBoard system)
   ═══════════════════════════════════════ */
:root {
    --accent: #c2410c;
    --accent-dim: rgba(194, 65, 12, 0.06);
    --accent-hover: #a93b0b;
    --accent-light: rgba(194, 65, 12, 0.1);
    --font-mono: 'IBM Plex Mono', monospace;
    --font-sans: 'Plus Jakarta Sans', sans-serif;
    --radius-sm: 6px;
    --radius-md: 10px;
    --bg-deep: #f5f3ef;
    --bg-primary: #ffffff;
    --bg-card: #ffffff;
    --bg-elevated: #fafaf8;
    --bg-hover: #f0eeea;
    --border: #e2e0db;
    --border-subtle: #eceae5;
    --text-primary: #1a1a1a;
    --text-secondary: #4a4a4a;
    --text-muted: #8a8a8a;
    --success: #16a34a;
    --success-dim: rgba(22, 163, 74, 0.08);
    --error: #dc2626;
    --error-dim: rgba(220, 38, 38, 0.06);
    --warning: #d97706;
    --warning-dim: rgba(217, 119, 6, 0.08);
    --info: #2563eb;
    --info-dim: rgba(37, 99, 235, 0.06);
}

* { margin: 0; padding: 0; box-sizing: border-box; }

body {
    font-family: var(--font-sans);
    background: var(--bg-deep);
    color: var(--text-primary);
    -webkit-font-smoothing: antialiased;
    min-height: 100vh;
}

@keyframes fade-in { from { opacity: 0; } to { opacity: 1; } }
@keyframes fade-in-up { from { opacity: 0; transform: translateY(12px); } to { opacity: 1; transform: translateY(0); } }

/* ═══════════════════════════════════════
   TOP BAR
   ═══════════════════════════════════════ */
.topbar {
    display: flex; align-items: center; justify-content: space-between;
    padding: 0 24px; height: 56px;
    background: var(--bg-primary); border-bottom: 1px solid var(--border);
    position: fixed; top: 0; left: 0; right: 0; z-index: 100;
}
.topbar-left { display: flex; align-items: center; gap: 20px; }
.logo {
    display: flex; align-items: center; gap: 10px;
    font-family: var(--font-sans); font-weight: 800; font-size: 17px;
    letter-spacing: -0.5px; text-decoration: none; color: var(--text-primary);
}
.logo-hex {
    width: 28px; height: 28px; background: var(--accent);
    clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
    display: flex; align-items: center; justify-content: center; flex-shrink: 0;
}
.logo-hex-inner {
    width: 18px; height: 18px; background: var(--bg-primary);
    clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
}
.logo span { color: var(--accent); }

.docs-badge {
    font-family: var(--font-mono); font-size: 11px; font-weight: 600;
    color: var(--accent); background: var(--accent-dim);
    padding: 3px 10px; border-radius: 4px;
    text-transform: uppercase; letter-spacing: 0.5px;
    border: 1px solid rgba(194, 65, 12, 0.12);
}

.topbar-right { display: flex; align-items: center; gap: 12px; }
.topbar-link {
    font-family: var(--font-sans); font-size: 13px; font-weight: 600;
    color: var(--text-secondary); text-decoration: none;
    padding: 7px 14px; border-radius: var(--radius-sm);
    transition: all 0.15s; border: 1px solid transparent;
}
.topbar-link:hover { background: var(--bg-hover); color: var(--text-primary); }
.topbar-link.primary {
    color: #fff; background: var(--accent); border-color: var(--accent);
}
.topbar-link.primary:hover { background: var(--accent-hover); }

/* ═══════════════════════════════════════
   LAYOUT
   ═══════════════════════════════════════ */
.docs-layout {
    display: flex; min-height: 100vh; padding-top: 56px;
}

/* ─── LEFT SIDEBAR ─── */
.docs-sidebar {
    width: 260px; flex-shrink: 0;
    background: var(--bg-primary);
    border-right: 1px solid var(--border);
    padding: 20px 12px;
    position: fixed; top: 56px; bottom: 0; left: 0;
    overflow-y: auto;
    scrollbar-width: thin;
    scrollbar-color: var(--border) transparent;
}
.docs-sidebar::-webkit-scrollbar { width: 4px; }
.docs-sidebar::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }

.docs-nav-section {
    font-family: var(--font-sans); font-size: 10px; font-weight: 700;
    text-transform: uppercase; letter-spacing: 0.8px;
    color: var(--text-muted); padding: 16px 12px 6px;
}
.docs-nav-section:first-child { padding-top: 0; }

.docs-nav-item {
    display: flex; align-items: center; gap: 10px;
    padding: 9px 12px; border-radius: var(--radius-sm);
    font-family: var(--font-sans); font-size: 13.5px; font-weight: 500;
    color: var(--text-secondary); text-decoration: none;
    transition: all 0.12s; border: 1px solid transparent;
}
.docs-nav-item:hover {
    background: var(--bg-hover); color: var(--text-primary);
}
.docs-nav-item.active {
    background: var(--accent-dim); color: var(--accent);
    font-weight: 600; border-color: rgba(194, 65, 12, 0.1);
}
.docs-nav-icon {
    width: 18px; height: 18px; flex-shrink: 0; opacity: 0.5;
    display: flex; align-items: center;
}
.docs-nav-icon svg { width: 18px; height: 18px; }
.docs-nav-item.active .docs-nav-icon { opacity: 1; color: var(--accent); }

/* ─── MAIN CONTENT ─── */
.docs-main {
    flex: 1; margin-left: 260px; margin-right: 220px;
    padding: 40px 48px 80px;
    max-width: 820px;
    animation: fade-in 0.3s ease;
}

/* ─── RIGHT TOC ─── */
.page-toc {
    position: fixed; top: 96px; right: 24px;
    width: 196px; max-height: calc(100vh - 120px);
    overflow-y: auto; scrollbar-width: thin;
    scrollbar-color: var(--border) transparent;
}
.page-toc::-webkit-scrollbar { width: 3px; }
.page-toc::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }

.page-toc-title {
    font-family: var(--font-sans); font-size: 10px; font-weight: 700;
    text-transform: uppercase; letter-spacing: 0.8px;
    color: var(--text-muted); padding-bottom: 8px;
    border-bottom: 1px solid var(--border-subtle);
    margin-bottom: 8px;
}
.toc-link {
    display: block; padding: 4px 0;
    font-family: var(--font-sans); font-size: 12.5px; font-weight: 500;
    color: var(--text-muted); text-decoration: none;
    transition: color 0.15s;
    line-height: 1.4;
    border-left: 2px solid transparent;
    padding-left: 10px;
    margin-left: -1px;
}
.toc-link:hover { color: var(--text-primary); }
.toc-link.toc-h3 { padding-left: 22px; font-size: 12px; }
.toc-link.active {
    color: var(--accent); font-weight: 600;
    border-left-color: var(--accent);
}

/* ═══════════════════════════════════════
   CONTENT TYPOGRAPHY
   ═══════════════════════════════════════ */
.doc-content h1 {
    font-family: var(--font-sans); font-size: 28px; font-weight: 800;
    letter-spacing: -0.7px; line-height: 1.2;
    margin-bottom: 8px; color: var(--text-primary);
}
.doc-content h2 {
    font-family: var(--font-sans); font-size: 21px; font-weight: 700;
    letter-spacing: -0.3px; line-height: 1.3;
    margin-top: 48px; margin-bottom: 16px;
    padding-top: 24px; border-top: 1px solid var(--border-subtle);
    color: var(--text-primary);
}
.doc-content h2:first-of-type { margin-top: 32px; border-top: none; padding-top: 0; }

.doc-content h3 {
    font-family: var(--font-sans); font-size: 17px; font-weight: 700;
    margin-top: 32px; margin-bottom: 12px;
    color: var(--text-primary);
}
.doc-content h4 {
    font-family: var(--font-sans); font-size: 15px; font-weight: 700;
    margin-top: 24px; margin-bottom: 8px;
    color: var(--text-secondary);
}

.heading-anchor {
    color: var(--accent); text-decoration: none;
    opacity: 0; font-weight: 400; margin-left: 6px;
    transition: opacity 0.15s;
}
h2:hover .heading-anchor,
h3:hover .heading-anchor,
h4:hover .heading-anchor { opacity: 0.5; }
.heading-anchor:hover { opacity: 1 !important; }

.doc-content p {
    font-size: 15px; line-height: 1.7;
    color: var(--text-secondary); margin-bottom: 16px;
}
.doc-content strong { color: var(--text-primary); font-weight: 600; }

.doc-content a {
    color: var(--accent); text-decoration: none;
    border-bottom: 1px solid rgba(194, 65, 12, 0.2);
    transition: border-color 0.15s;
}
.doc-content a:hover { border-bottom-color: var(--accent); }

.doc-content ul, .doc-content ol {
    margin-bottom: 16px; padding-left: 24px;
}
.doc-content li {
    font-size: 15px; line-height: 1.7;
    color: var(--text-secondary); margin-bottom: 6px;
}
.doc-content li strong { color: var(--text-primary); }

/* Inline code */
.doc-content code {
    font-family: var(--font-mono); font-size: 13px; font-weight: 500;
    color: var(--accent); background: var(--accent-dim);
    padding: 2px 6px; border-radius: 4px;
    border: 1px solid rgba(194, 65, 12, 0.08);
}

/* Code blocks */
.code-block {
    position: relative; margin-bottom: 20px;
    background: #1e1e2e; border-radius: var(--radius-md);
    border: 1px solid #2a2a3e;
    overflow: hidden;
}
.code-block .code-lang {
    position: absolute; top: 0; right: 0;
    font-family: var(--font-mono); font-size: 10px; font-weight: 600;
    text-transform: uppercase; letter-spacing: 0.5px;
    color: #8888aa; background: rgba(255,255,255,0.05);
    padding: 4px 12px; border-radius: 0 var(--radius-md) 0 6px;
}
.code-block pre {
    margin: 0; padding: 20px 24px; overflow-x: auto;
    scrollbar-width: thin; scrollbar-color: #444 transparent;
}
.code-block pre::-webkit-scrollbar { height: 4px; }
.code-block pre::-webkit-scrollbar-thumb { background: #555; border-radius: 2px; }
.code-block pre code {
    font-family: var(--font-mono); font-size: 13px; line-height: 1.6;
    color: #cdd6f4; background: none; padding: 0; border: none; border-radius: 0;
}

/* Tables */
.table-wrapper {
    margin-bottom: 20px; overflow-x: auto;
    border: 1px solid var(--border); border-radius: var(--radius-md);
    scrollbar-width: thin;
}
.table-wrapper table {
    width: 100%; border-collapse: collapse;
    font-size: 14px;
}
.table-wrapper th {
    font-family: var(--font-sans); font-size: 12px; font-weight: 700;
    text-transform: uppercase; letter-spacing: 0.4px;
    color: var(--text-muted); background: var(--bg-elevated);
    text-align: left; padding: 10px 16px;
    border-bottom: 1px solid var(--border);
}
.table-wrapper td {
    font-family: var(--font-sans); font-size: 14px; line-height: 1.5;
    color: var(--text-secondary); padding: 10px 16px;
    border-bottom: 1px solid var(--border-subtle);
    vertical-align: top;
}
.table-wrapper tr:last-child td { border-bottom: none; }
.table-wrapper tr:hover td { background: var(--bg-elevated); }
.table-wrapper td code {
    font-size: 12px;
}

/* Blockquotes / Callouts */
.callout {
    margin-bottom: 20px; padding: 16px 20px;
    border-left: 3px solid var(--border);
    border-radius: 0 var(--radius-sm) var(--radius-sm) 0;
    background: var(--bg-elevated);
}
.callout p { margin-bottom: 8px; font-size: 14px; }
.callout p:last-child { margin-bottom: 0; }
.callout em { color: var(--text-muted); }

.callout-warning {
    border-left-color: var(--warning);
    background: var(--warning-dim);
}
.callout-tip {
    border-left-color: var(--success);
    background: var(--success-dim);
}
.callout-info {
    border-left-color: var(--info);
    background: var(--info-dim);
}
.callout-danger {
    border-left-color: var(--error);
    background: var(--error-dim);
}

/* HR */
.doc-content hr {
    border: none; height: 1px;
    background: var(--border); margin: 32px 0;
}

/* ─── VERSION BADGE ─── */
.doc-meta {
    display: flex; align-items: center; gap: 12px;
    margin-bottom: 24px;
}
.doc-meta-badge {
    font-family: var(--font-mono); font-size: 11px; font-weight: 600;
    color: var(--text-muted); background: var(--bg-elevated);
    padding: 3px 10px; border-radius: 4px;
    border: 1px solid var(--border-subtle);
}

/* ─── PREV / NEXT NAV ─── */
.prev-next {
    display: flex; gap: 16px; margin-top: 48px;
    padding-top: 24px; border-top: 1px solid var(--border);
}
.prev-next-link {
    flex: 1; display: block; padding: 16px 20px;
    background: var(--bg-primary); border: 1px solid var(--border);
    border-radius: var(--radius-md); text-decoration: none;
    transition: all 0.15s;
}
.prev-next-link:hover {
    border-color: var(--accent); background: var(--accent-dim);
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(194, 65, 12, 0.06);
}
.prev-next-link.next { text-align: right; }
.prev-next-label {
    font-family: var(--font-sans); font-size: 12px; font-weight: 600;
    color: var(--text-muted); display: block; margin-bottom: 4px;
}
.prev-next-title {
    font-family: var(--font-sans); font-size: 15px; font-weight: 700;
    color: var(--text-primary);
}
.prev-next-link:hover .prev-next-title { color: var(--accent); }

/* ─── MOBILE MENU ─── */
.mobile-menu-toggle {
    display: none; align-items: center; justify-content: center;
    width: 36px; height: 36px; border: 1px solid var(--border);
    border-radius: var(--radius-sm); background: var(--bg-primary);
    cursor: pointer; color: var(--text-secondary);
}

/* ═══════════════════════════════════════
   RESPONSIVE
   ═══════════════════════════════════════ */
@media (max-width: 1200px) {
    .page-toc { display: none; }
    .docs-main { margin-right: 0; }
}

@media (max-width: 860px) {
    .mobile-menu-toggle { display: flex; }
    .docs-sidebar {
        transform: translateX(-100%);
        transition: transform 0.25s ease;
        z-index: 50;
        box-shadow: none;
    }
    .docs-sidebar.open {
        transform: translateX(0);
        box-shadow: 8px 0 30px rgba(0,0,0,0.1);
    }
    .docs-main {
        margin-left: 0; padding: 28px 20px 60px;
    }
    .doc-content h1 { font-size: 24px; }
    .doc-content h2 { font-size: 19px; }
    .prev-next { flex-direction: column; }
}

/* ═══════════════════════════════════════
   PRISM THEME OVERRIDES (dark code blocks)
   ═══════════════════════════════════════ */
.code-block .token.comment,
.code-block .token.prolog,
.code-block .token.doctype { color: #6c7086; }
.code-block .token.punctuation { color: #a6adc8; }
.code-block .token.property,
.code-block .token.tag,
.code-block .token.boolean,
.code-block .token.number { color: #fab387; }
.code-block .token.string,
.code-block .token.attr-value { color: #a6e3a1; }
.code-block .token.selector,
.code-block .token.attr-name,
.code-block .token.builtin { color: #89b4fa; }
.code-block .token.keyword { color: #cba6f7; }
.code-block .token.function { color: #89b4fa; }
.code-block .token.operator { color: #89dceb; }
.code-block .token.class-name { color: #f9e2af; }
.code-block .token.decorator { color: #f38ba8; }
</style>
</head>
<body>

<!-- TOP BAR -->
<div class="topbar">
    <div class="topbar-left">
        <a href="home.html" class="logo">
            <div class="logo-hex"><div class="logo-hex-inner"></div></div>
            Hive<span>Board</span>
        </a>
        <span class="docs-badge">Docs</span>
    </div>
    <div class="topbar-right">
        <button class="mobile-menu-toggle" id="mobileMenuToggle" aria-label="Toggle navigation">
            <svg width="18" height="18" viewBox="0 0 18 18" fill="none"><path d="M3 5h12M3 9h12M3 13h12" stroke="currentColor" stroke-width="1.4" stroke-linecap="round"/></svg>
        </button>
        <a href="https://github.com/hiveboard/hiveloop" class="topbar-link" target="_blank" rel="noopener">GitHub</a>
        <a href="home.html" class="topbar-link primary">Open Dashboard</a>
    </div>
</div>

<!-- LAYOUT -->
<div class="docs-layout">
    <!-- SIDEBAR -->
    <nav class="docs-sidebar" id="docsSidebar">
<div class="docs-nav-section">Getting Started</div>
<a class="docs-nav-item" href="user-manual.html"><span class="docs-nav-icon"><svg viewBox="0 0 18 18" fill="none"><path d="M2 3.5A1.5 1.5 0 013.5 2H7a2 2 0 012 2v12.5l-.5-.5-3-3H3.5A1.5 1.5 0 012 11.5v-8z" stroke="currentColor" stroke-width="1.3"/><path d="M16 3.5A1.5 1.5 0 0014.5 2H11a2 2 0 00-2 2v12.5l.5-.5 3-3h2A1.5 1.5 0 0016 11.5v-8z" stroke="currentColor" stroke-width="1.3"/></svg></span><span>SDK Manual</span></a>
<a class="docs-nav-item" href="integration-guide.html"><span class="docs-nav-icon"><svg viewBox="0 0 18 18" fill="none"><path d="M6 2v4M12 2v4M4 6h10v3a5 5 0 01-5 5 5 5 0 01-5-5V6zM9 14v3" stroke="currentColor" stroke-width="1.3" stroke-linecap="round" stroke-linejoin="round"/></svg></span><span>Integration Guide</span></a>
<div class="docs-nav-section">Dashboard</div>
<a class="docs-nav-item" href="docs-dashboard-guide.html"><span class="docs-nav-icon"><svg viewBox="0 0 18 18" fill="none"><rect x="2" y="2" width="14" height="14" rx="2" stroke="currentColor" stroke-width="1.3"/><path d="M2 7h14M7 7v9" stroke="currentColor" stroke-width="1.3"/></svg></span><span>Dashboard Guide</span></a>
<div class="docs-nav-section">Instrumentation</div>
<a class="docs-nav-item" href="docs-instrumentation-guide.html"><span class="docs-nav-icon"><svg viewBox="0 0 18 18" fill="none"><circle cx="9" cy="9" r="7" stroke="currentColor" stroke-width="1.3"/><circle cx="9" cy="9" r="4" stroke="currentColor" stroke-width="1.3"/><circle cx="9" cy="9" r="1" fill="currentColor"/></svg></span><span>Instrumentation</span></a>
<a class="docs-nav-item" href="docs-layer1-guide.html"><span class="docs-nav-icon"><svg viewBox="0 0 18 18" fill="none"><path d="M9 2L2 6l7 4 7-4-7-4zM2 12l7 4 7-4M2 9l7 4 7-4" stroke="currentColor" stroke-width="1.3" stroke-linecap="round" stroke-linejoin="round"/></svg></span><span>Layer 1 Guide</span></a>
<div class="docs-nav-section">Rich Events</div>
<a class="docs-nav-item" href="docs-layer2-rich-events.html"><span class="docs-nav-icon"><svg viewBox="0 0 18 18" fill="none"><path d="M10 2L3 10h5l-1 6 7-8h-5l1-6z" stroke="currentColor" stroke-width="1.3" stroke-linecap="round" stroke-linejoin="round"/></svg></span><span>Rich Events</span></a>
<a class="docs-nav-item" href="docs-layer2-llm-tracking.html"><span class="docs-nav-icon"><svg viewBox="0 0 18 18" fill="none"><rect x="4" y="4" width="10" height="10" rx="1.5" stroke="currentColor" stroke-width="1.3"/><rect x="7" y="7" width="4" height="4" rx="0.5" stroke="currentColor" stroke-width="1.3"/><path d="M7 2v2M11 2v2M7 14v2M11 14v2M2 7h2M2 11h2M14 7h2M14 11h2" stroke="currentColor" stroke-width="1.3" stroke-linecap="round"/></svg></span><span>LLM Tracking</span></a>
<a class="docs-nav-item active" href="docs-operational-events.html"><span class="docs-nav-icon"><svg viewBox="0 0 18 18" fill="none"><path d="M16 9h-3l-2 7L7 2 5 9H2" stroke="currentColor" stroke-width="1.3" stroke-linecap="round" stroke-linejoin="round"/></svg></span><span>Operational Events</span></a>
<a class="docs-nav-item" href="docs-track-context.html"><span class="docs-nav-icon"><svg viewBox="0 0 18 18" fill="none"><circle cx="5" cy="5" r="2" stroke="currentColor" stroke-width="1.3"/><circle cx="13" cy="5" r="2" stroke="currentColor" stroke-width="1.3"/><circle cx="5" cy="13" r="2" stroke="currentColor" stroke-width="1.3"/><path d="M5 7v4M13 7c0 3-2 4-8 4" stroke="currentColor" stroke-width="1.3"/></svg></span><span>Track Context</span></a>

    </nav>

    <!-- MAIN CONTENT -->
    <main class="docs-main">
        <div class="doc-meta">
            <span class="doc-meta-badge">v0.1.0</span>
            <span class="doc-meta-badge">Updated Feb 2026</span>
        </div>
        <article class="doc-content">
<h1 id="hiveloop-user-manual-part-7-operational-events-integration-guide">HiveLoop — User Manual Part 7: Operational Events Integration Guide <a class="heading-anchor" href="#hiveloop-user-manual-part-7-operational-events-integration-guide" aria-label="Link to this section">#</a></h1>
<p><strong>Version:</strong> 0.1.0
<strong>Last updated:</strong> 2026-02-12</p>
<blockquote class="callout"><p><em>Plans, escalations, issues, retries, and queue snapshots — the methods that turn a timeline into a narrative your ops team can act on.</em></p></blockquote>
<hr />
<h2 id="table-of-contents">Table of Contents <a class="heading-anchor" href="#table-of-contents" aria-label="Link to this section">#</a></h2>
<ol>
<li><a href="#1-what-this-guide-covers">What This Guide Covers</a></li>
<li><a href="#2-the-integration-mindset">The Integration Mindset</a></li>
<li><a href="#3-plans--taskplan-and-taskplan_step">Plans — <code>task.plan()</code> and <code>task.plan_step()</code></a></li>
<li><a href="#4-escalations--taskescalate">Escalations — <code>task.escalate()</code></a></li>
<li><a href="#5-issues--agentreport_issue">Issues — <code>agent.report_issue()</code></a></li>
<li><a href="#6-queue-snapshots--agentqueue_snapshot">Queue Snapshots — <code>agent.queue_snapshot()</code></a></li>
<li><a href="#7-retries--taskretry">Retries — <code>task.retry()</code></a></li>
<li><a href="#8-tool-execution-tracking--agenttrack_context">Tool Execution Tracking — <code>agent.track_context()</code></a></li>
<li><a href="#9-putting-it-all-together">Putting It All Together</a></li>
<li><a href="#10-finding-integration-points-in-your-codebase">Finding Integration Points in Your Codebase</a></li>
<li><a href="#11-validation-checklists">Validation Checklists</a></li>
<li><a href="#12-common-mistakes">Common Mistakes</a></li>
</ol>
<hr />
<h2 id="1-what-this-guide-covers">1. What This Guide Covers <a class="heading-anchor" href="#1-what-this-guide-covers" aria-label="Link to this section">#</a></h2>
<p>This guide covers five SDK methods that add operational context to your agent's telemetry. These are <strong>Layer 2 events</strong> — they build on top of Layer 0 (init + heartbeat) and Layer 1 (tasks + actions), adding the narrative that answers &quot;why did it fail?&quot; and &quot;what is it waiting for?&quot;</p>
<div class="table-wrapper"><table>
<thead>
<tr>
  <th>Method</th>
  <th>Scope</th>
  <th>What it answers</th>
</tr>
</thead>
<tbody>
<tr>
  <td><code>task.plan()</code> + <code>task.plan_step()</code></td>
  <td>Task</td>
  <td>What is the agent's strategy? Which step failed? How far did it get?</td>
</tr>
<tr>
  <td><code>task.escalate()</code></td>
  <td>Task</td>
  <td>When did the agent decide it needs help? Who did it hand off to?</td>
</tr>
<tr>
  <td><code>agent.report_issue()</code></td>
  <td>Agent</td>
  <td>What persistent problems has the agent detected?</td>
</tr>
<tr>
  <td><code>agent.queue_snapshot()</code></td>
  <td>Agent</td>
  <td>How deep is the work queue? Is the agent falling behind?</td>
</tr>
<tr>
  <td><code>task.retry()</code></td>
  <td>Task</td>
  <td>How many retries? What triggered them? How much time is lost?</td>
</tr>
<tr>
  <td><code>agent.track_context()</code></td>
  <td>Task</td>
  <td>Which tools were called? How long did each take? Which failed?</td>
</tr>
</tbody>
</table></div>
<h3 id="prerequisites">Prerequisites <a class="heading-anchor" href="#prerequisites" aria-label="Link to this section">#</a></h3>
<p>Before integrating these methods, you should have:</p>
<ul>
<li>[x] Layer 0 working — <code>hiveloop.init()</code> + <code>hb.agent()</code>, agents visible with heartbeats</li>
<li>[x] Layer 1 working — <code>agent.task()</code> + <code>@agent.track()</code>, tasks and actions in the timeline</li>
<li>[x] A plumbing pattern in place — <code>contextvars</code>, parameter passing, or framework context (see Part 3, Section 5)</li>
</ul>
<p>If Layer 1 isn't working yet, go back to Part 3 (Instrumentation Guide) and Part 4 (Layer 1 — What to Expect). These operational events build on task context and are meaningless without it.</p>
<hr />
<h2 id="2-the-integration-mindset">2. The Integration Mindset <a class="heading-anchor" href="#2-the-integration-mindset" aria-label="Link to this section">#</a></h2>
<p>These five methods share a pattern that's different from <code>task.llm_call()</code> and <code>@agent.track()</code>:</p>
<p><strong>LLM calls and action tracking</strong> are about <em>measuring</em> — they record something that already happened (a function ran, a model was called). You find the call site and add a line after it.</p>
<p><strong>Operational events</strong> are about <em>narrating</em> — they describe the agent's decisions, problems, and state transitions. The code that triggers them often doesn't look like a function call you can easily spot. You need to understand the agent's decision-making flow to know where to add them.</p>
<h3 id="what-to-look-for">What to look for <a class="heading-anchor" href="#what-to-look-for" aria-label="Link to this section">#</a></h3>
<div class="table-wrapper"><table>
<thead>
<tr>
  <th>Method</th>
  <th>Code pattern to search for</th>
</tr>
</thead>
<tbody>
<tr>
  <td><code>task.plan()</code></td>
  <td>Step lists, strategy objects, workflow definitions, phase arrays</td>
</tr>
<tr>
  <td><code>task.plan_step()</code></td>
  <td>Progress tracking, step iteration, phase transitions</td>
</tr>
<tr>
  <td><code>task.escalate()</code></td>
  <td>Handoffs, delegation, &quot;needs human review&quot; logic</td>
</tr>
<tr>
  <td><code>agent.report_issue()</code></td>
  <td>Error detection outside of task failures, degraded conditions, health checks</td>
</tr>
<tr>
  <td><code>agent.queue_snapshot()</code></td>
  <td>Work queues, job lists, pending items, inbox polling</td>
</tr>
<tr>
  <td><code>task.retry()</code></td>
  <td>Retry loops, backoff logic, <code>tenacity</code> decorators, <code>for attempt in range(N)</code></td>
</tr>
</tbody>
</table></div>
<hr />
<h2 id="3-plans-taskplan-and-taskplan_step">3. Plans — <code>task.plan()</code> and <code>task.plan_step()</code> <a class="heading-anchor" href="#3-plans-taskplan-and-taskplan_step" aria-label="Link to this section">#</a></h2>
<h3 id="31-what-it-does">3.1 What it does <a class="heading-anchor" href="#31-what-it-does" aria-label="Link to this section">#</a></h3>
<p>When your agent creates a multi-step strategy — &quot;first do X, then Y, then Z&quot; — <code>task.plan()</code> makes that strategy visible on the dashboard. <code>task.plan_step()</code> updates each step's status as the agent progresses.</p>
<p>On the dashboard, this renders as a <strong>plan progress bar</strong> above the timeline:</p>
<div class="code-block"><pre><code>[■ Search CRM] [■ Score lead] [▪ Generate email] [  Update CRM  ]
   completed      completed      in progress        not started
</code></pre></div>
<h3 id="32-the-api">3.2 The API <a class="heading-anchor" href="#32-the-api" aria-label="Link to this section">#</a></h3>
<p><strong><code>task.plan(goal, steps)</code></strong> — declare the plan:</p>
<div class="code-block"><span class="code-lang">python</span><pre><code class="language-python">task.plan(
    &quot;Process and route incoming lead&quot;,       # goal — what the plan achieves
    [                                        # steps — ordered list of step descriptions
        &quot;Search CRM for existing record&quot;,
        &quot;Score lead against criteria&quot;,
        &quot;Generate follow-up email&quot;,
        &quot;Update CRM with outcome&quot;,
    ],
)
</code></pre></div>
<div class="table-wrapper"><table>
<thead>
<tr>
  <th>Parameter</th>
  <th>Type</th>
  <th>Required</th>
  <th>Description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><code>goal</code></td>
  <td>str</td>
  <td><strong>Yes</strong></td>
  <td>What the plan aims to achieve</td>
</tr>
<tr>
  <td><code>steps</code></td>
  <td>list[str]</td>
  <td><strong>Yes</strong></td>
  <td>Ordered step descriptions. Order determines step indices (0, 1, 2, ...)</td>
</tr>
<tr>
  <td><code>revision</code></td>
  <td>int</td>
  <td>No</td>
  <td>Plan revision number. Default <code>0</code>. Increment when the agent replans</td>
</tr>
</tbody>
</table></div>
<p><strong><code>task.plan_step(step_index, action, summary)</code></strong> — update a step:</p>
<div class="code-block"><span class="code-lang">python</span><pre><code class="language-python">task.plan_step(0, &quot;started&quot;, &quot;Searching CRM for lead #4801&quot;)
# ... step executes ...
task.plan_step(0, &quot;completed&quot;, &quot;Found existing CRM record&quot;,
               turns=2, tokens=3200)
</code></pre></div>
<div class="table-wrapper"><table>
<thead>
<tr>
  <th>Parameter</th>
  <th>Type</th>
  <th>Required</th>
  <th>Description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><code>step_index</code></td>
  <td>int</td>
  <td><strong>Yes</strong></td>
  <td>Zero-based position in the steps list</td>
</tr>
<tr>
  <td><code>action</code></td>
  <td>str</td>
  <td><strong>Yes</strong></td>
  <td><code>&quot;started&quot;</code>, <code>&quot;completed&quot;</code>, <code>&quot;failed&quot;</code>, <code>&quot;skipped&quot;</code></td>
</tr>
<tr>
  <td><code>summary</code></td>
  <td>str</td>
  <td><strong>Yes</strong></td>
  <td>Outcome or status note</td>
</tr>
<tr>
  <td><code>total_steps</code></td>
  <td>int</td>
  <td>No</td>
  <td>Auto-inferred from <code>task.plan()</code> if previously called</td>
</tr>
<tr>
  <td><code>turns</code></td>
  <td>int</td>
  <td>No</td>
  <td>LLM turns spent on this step</td>
</tr>
<tr>
  <td><code>tokens</code></td>
  <td>int</td>
  <td>No</td>
  <td>Total tokens spent on this step</td>
</tr>
<tr>
  <td><code>plan_revision</code></td>
  <td>int</td>
  <td>No</td>
  <td>Correlates with <code>task.plan()</code> revision</td>
</tr>
</tbody>
</table></div>
<h3 id="33-finding-where-to-add-plans">3.3 Finding WHERE to add plans <a class="heading-anchor" href="#33-finding-where-to-add-plans" aria-label="Link to this section">#</a></h3>
<p>Search your codebase for code that:</p>
<ol>
<li><p><strong>Creates a sequence of steps to execute.</strong> Look for lists, arrays, or objects that define a strategy:</p>
<div class="code-block"><span class="code-lang">python</span><pre><code class="language-python"># Pattern A — explicit step list
steps = [&quot;fetch data&quot;, &quot;analyze&quot;, &quot;generate report&quot;, &quot;send email&quot;]

# Pattern B — workflow/pipeline definition
pipeline = [FetchStage(), AnalyzeStage(), ReportStage()]

# Pattern C — LLM-generated plan
plan = llm.create_plan(objective)  # returns structured steps
</code></pre></div>
</li>
<li><p><strong>Iterates through stages or phases.</strong> The agent processes work in a defined order:</p>
<div class="code-block"><span class="code-lang">python</span><pre><code class="language-python">for i, step in enumerate(pipeline.stages):
    step.execute(context)
</code></pre></div>
</li>
<li><p><strong>Tracks progress through sequential work.</strong> Counters, phase variables, or state machines:</p>
<div class="code-block"><span class="code-lang">python</span><pre><code class="language-python">current_phase = &quot;scoring&quot;
# ... later ...
current_phase = &quot;routing&quot;
</code></pre></div>
</li>
</ol>
<h3 id="34-integration-pattern">3.4 Integration pattern <a class="heading-anchor" href="#34-integration-pattern" aria-label="Link to this section">#</a></h3>
<p>Once you've found the plan creation point and the step execution loop, add instrumentation:</p>
<div class="code-block"><span class="code-lang">python</span><pre><code class="language-python">from myproject.observability import get_current_task

def execute_plan(objective, data):
    task = get_current_task()

    # Step 1: Agent creates its plan
    steps = planner.generate_steps(objective)

    if task:
        task.plan(objective, [s.description for s in steps])

    # Step 2: Execute each step, tracking progress
    for i, step in enumerate(steps):
        if task:
            task.plan_step(i, &quot;started&quot;, step.description)

        try:
            result = step.execute(data)
            if task:
                task.plan_step(i, &quot;completed&quot;, f&quot;{step.description} — {result.summary}&quot;)
        except Exception as e:
            if task:
                task.plan_step(i, &quot;failed&quot;, f&quot;{step.description} — {e}&quot;)
            raise
</code></pre></div>
<h3 id="35-replanning">3.5 Replanning <a class="heading-anchor" href="#35-replanning" aria-label="Link to this section">#</a></h3>
<p>If the agent changes its plan mid-execution (e.g., after a step fails and it creates a new strategy), call <code>task.plan()</code> again with an incremented <code>revision</code>:</p>
<div class="code-block"><span class="code-lang">python</span><pre><code class="language-python"># Original plan failed at step 2
task.plan_step(2, &quot;failed&quot;, &quot;Email API returned 403&quot;)

# Agent replans
new_steps = planner.replan(objective, failed_step=2)
task.plan(&quot;Revised: route to manual review&quot;, [s.description for s in new_steps], revision=1)

# Continue with new plan
task.plan_step(0, &quot;started&quot;, &quot;Notifying manager&quot;)
</code></pre></div>
<p>The dashboard shows the latest plan. Previous plan events remain in the timeline for the full history.</p>
<h3 id="36-loopcore-example">3.6 loopCore example <a class="heading-anchor" href="#36-loopcore-example" aria-label="Link to this section">#</a></h3>
<p>In loopCore, the planning system creates execution plans with explicit step lists:</p>
<p><strong>Plan creation — <code>planning.py</code>:</strong></p>
<div class="code-block"><span class="code-lang">python</span><pre><code class="language-python"># After the LLM generates a plan:
plan_steps = parse_plan_response(plan_response)

task = get_current_task()
if task:
    try:
        task.plan(
            objective,
            [step[&quot;description&quot;] for step in plan_steps],
        )
    except Exception:
        pass
</code></pre></div>
<p><strong>Step execution — <code>loop.py</code>:</strong></p>
<div class="code-block"><span class="code-lang">python</span><pre><code class="language-python"># As each step is processed in the agent loop:
task = get_current_task()
if task:
    try:
        task.plan_step(step_index, &quot;started&quot;, f&quot;Executing: {step_name}&quot;)
    except Exception:
        pass

# ... step executes ...

if task:
    try:
        task.plan_step(step_index, &quot;completed&quot;, step_result_summary,
                       turns=turns_used, tokens=tokens_spent)
    except Exception:
        pass
</code></pre></div>
<h3 id="37-dashboard-impact">3.7 Dashboard impact <a class="heading-anchor" href="#37-dashboard-impact" aria-label="Link to this section">#</a></h3>
<div class="table-wrapper"><table>
<thead>
<tr>
  <th>Element</th>
  <th>What appears</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>Timeline</strong></td>
  <td>Plan progress bar above the main track. Green = completed, blue = in progress, red = failed, gray = not started</td>
</tr>
<tr>
  <td><strong>Timeline detail</strong></td>
  <td>Click a plan node to see goal, step count, and revision</td>
</tr>
<tr>
  <td><strong>Activity Stream</strong></td>
  <td><code>plan_created</code> and <code>plan_step</code> events with step index and status</td>
</tr>
</tbody>
</table></div>
<hr />
<h2 id="4-escalations-taskescalate">4. Escalations — <code>task.escalate()</code> <a class="heading-anchor" href="#4-escalations-taskescalate" aria-label="Link to this section">#</a></h2>
<h3 id="41-what-it-does">4.1 What it does <a class="heading-anchor" href="#41-what-it-does" aria-label="Link to this section">#</a></h3>
<p><code>task.escalate()</code> records the moment an agent decides it cannot handle something alone. This is a critical operational signal — it means the agent needs human intervention, a different agent, or a different approach.</p>
<h3 id="42-the-api">4.2 The API <a class="heading-anchor" href="#42-the-api" aria-label="Link to this section">#</a></h3>
<div class="code-block"><span class="code-lang">python</span><pre><code class="language-python">task.escalate(
    &quot;Lead score 0.12 — below threshold, needs manual review&quot;,
    assigned_to=&quot;senior-sales&quot;,
)
</code></pre></div>
<div class="table-wrapper"><table>
<thead>
<tr>
  <th>Parameter</th>
  <th>Type</th>
  <th>Required</th>
  <th>Description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><code>summary</code></td>
  <td>str</td>
  <td><strong>Yes</strong></td>
  <td>Why the agent escalated — this appears on the timeline and in the Activity Stream</td>
</tr>
<tr>
  <td><code>assigned_to</code></td>
  <td>str</td>
  <td>No</td>
  <td>Who or what receives the escalation (person, team, queue, agent)</td>
</tr>
<tr>
  <td><code>reason</code></td>
  <td>str</td>
  <td>No</td>
  <td>Additional reason detail (if summary isn't enough)</td>
</tr>
</tbody>
</table></div>
<h3 id="43-finding-where-to-add-escalations">4.3 Finding WHERE to add escalations <a class="heading-anchor" href="#43-finding-where-to-add-escalations" aria-label="Link to this section">#</a></h3>
<p>Escalation points are where the agent says &quot;I can't handle this.&quot; Search for:</p>
<ol>
<li><p><strong>Threshold checks that route to humans:</strong></p>
<div class="code-block"><span class="code-lang">python</span><pre><code class="language-python">if confidence &lt; MIN_CONFIDENCE:
    notify_human(result)          # ← escalation point
</code></pre></div>
</li>
<li><p><strong>Error handling that delegates:</strong></p>
<div class="code-block"><span class="code-lang">python</span><pre><code class="language-python">except PermissionError:
    queue_for_manual_review(item)  # ← escalation point
</code></pre></div>
</li>
<li><p><strong>Decision logic with a &quot;give up&quot; branch:</strong></p>
<div class="code-block"><span class="code-lang">python</span><pre><code class="language-python">if retries_exhausted:
    hand_off_to_senior(task)       # ← escalation point
</code></pre></div>
</li>
<li><p><strong>Explicit escalation methods or flags:</strong></p>
<div class="code-block"><span class="code-lang">python</span><pre><code class="language-python">def escalate_to_human(self, reason):   # ← the method name itself is the clue
    self.status = &quot;escalated&quot;
</code></pre></div>
</li>
<li><p><strong>LLM-driven escalation decisions:</strong></p>
<div class="code-block"><span class="code-lang">python</span><pre><code class="language-python">if llm_decision == &quot;escalate&quot;:
    assign_to_human(context)        # ← escalation point
</code></pre></div>
</li>
</ol>
<h3 id="44-integration-pattern">4.4 Integration pattern <a class="heading-anchor" href="#44-integration-pattern" aria-label="Link to this section">#</a></h3>
<p>Add <code>task.escalate()</code> at the point where the escalation decision is made — before the actual handoff logic:</p>
<div class="code-block"><span class="code-lang">python</span><pre><code class="language-python">from myproject.observability import get_current_task

def handle_low_confidence_result(item, score):
    task = get_current_task()
    if task:
        try:
            task.escalate(
                f&quot;Score {score:.2f} below threshold — needs manual review&quot;,
                assigned_to=&quot;senior-sales&quot;,
            )
        except Exception:
            pass

    # Existing escalation logic (unchanged):
    queue_for_review(item, assignee=&quot;senior-sales&quot;)
</code></pre></div>
<h3 id="45-loopcore-example">4.5 loopCore example <a class="heading-anchor" href="#45-loopcore-example" aria-label="Link to this section">#</a></h3>
<p>In loopCore, escalation happens when the reflection engine decides the agent should hand off:</p>
<p><strong><code>loop.py</code> — reflection returns &quot;escalate&quot;:</strong></p>
<div class="code-block"><span class="code-lang">python</span><pre><code class="language-python">if reflection_decision == &quot;escalate&quot;:
    task = get_current_task()
    if task:
        try:
            task.escalate(
                f&quot;Agent escalated: {reflection_reason}&quot;,
                assigned_to=&quot;human-reviewer&quot;,
            )
        except Exception:
            pass

    # Existing escalation flow continues:
    create_escalation_event(agent, reason=reflection_reason)
</code></pre></div>
<h3 id="46-escalation-vs-approval">4.6 Escalation vs. approval <a class="heading-anchor" href="#46-escalation-vs-approval" aria-label="Link to this section">#</a></h3>
<p>These are related but different:</p>
<div class="table-wrapper"><table>
<thead>
<tr>
  <th>Concept</th>
  <th>When to use</th>
  <th>Example</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>Escalation</strong></td>
  <td>Agent hands off work entirely</td>
  <td>&quot;I can't handle this billing dispute — routing to senior support&quot;</td>
</tr>
<tr>
  <td><strong>Approval request</strong></td>
  <td>Agent pauses and waits for permission</td>
  <td>&quot;I want to issue a $500 credit — need manager approval before proceeding&quot;</td>
</tr>
</tbody>
</table></div>
<p>If the agent <strong>stops working and waits</strong>, use <code>task.request_approval()</code> (see Part 5, Section 5). If the agent <strong>passes the work to someone else and moves on</strong>, use <code>task.escalate()</code>.</p>
<p>Some workflows involve both — escalate, then wait for approval:</p>
<div class="code-block"><span class="code-lang">python</span><pre><code class="language-python">task.escalate(&quot;Complex case — needs senior review&quot;, assigned_to=&quot;senior-support&quot;)
task.request_approval(&quot;Approval needed for account credit&quot;, approver=&quot;support-lead&quot;)
# ... agent waits ...
task.approval_received(&quot;Credit approved&quot;, approved_by=&quot;support-lead&quot;, decision=&quot;approved&quot;)
</code></pre></div>
<h3 id="47-dashboard-impact">4.7 Dashboard impact <a class="heading-anchor" href="#47-dashboard-impact" aria-label="Link to this section">#</a></h3>
<div class="table-wrapper"><table>
<thead>
<tr>
  <th>Element</th>
  <th>What appears</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>Timeline</strong></td>
  <td>Amber escalation node with the summary text</td>
</tr>
<tr>
  <td><strong>Activity Stream</strong></td>
  <td><code>escalated</code> event, visible under the &quot;human&quot; filter</td>
</tr>
<tr>
  <td><strong>Agent card</strong></td>
  <td>No direct badge change (escalation doesn't block the agent, unlike approval)</td>
</tr>
</tbody>
</table></div>
<hr />
<h2 id="5-issues-agentreport_issue">5. Issues — <code>agent.report_issue()</code> <a class="heading-anchor" href="#5-issues-agentreport_issue" aria-label="Link to this section">#</a></h2>
<h3 id="51-what-it-does">5.1 What it does <a class="heading-anchor" href="#51-what-it-does" aria-label="Link to this section">#</a></h3>
<p><code>agent.report_issue()</code> lets agents self-report persistent problems. Unlike task failures (which are automatic and per-task), issues are agent-level and persistent — they represent ongoing conditions like &quot;CRM API is returning 403s&quot; or &quot;data quality is degrading.&quot;</p>
<p>Issues stay active on the dashboard until explicitly resolved with <code>agent.resolve_issue()</code>.</p>
<h3 id="52-the-api">5.2 The API <a class="heading-anchor" href="#52-the-api" aria-label="Link to this section">#</a></h3>
<p><strong>Report an issue:</strong></p>
<div class="code-block"><span class="code-lang">python</span><pre><code class="language-python">agent.report_issue(
    summary=&quot;CRM API returning 403 for workspace queries&quot;,
    severity=&quot;high&quot;,
    issue_id=&quot;crm-403&quot;,
    category=&quot;permissions&quot;,
    context={&quot;api&quot;: &quot;salesforce&quot;, &quot;error_code&quot;: 403, &quot;last_seen&quot;: &quot;2026-02-12T14:30:00Z&quot;},
    occurrence_count=3,
)
</code></pre></div>
<div class="table-wrapper"><table>
<thead>
<tr>
  <th>Parameter</th>
  <th>Type</th>
  <th>Required</th>
  <th>Description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><code>summary</code></td>
  <td>str</td>
  <td><strong>Yes</strong></td>
  <td>Issue description. Used for dedup if no <code>issue_id</code></td>
</tr>
<tr>
  <td><code>severity</code></td>
  <td>str</td>
  <td><strong>Yes</strong></td>
  <td><code>&quot;critical&quot;</code>, <code>&quot;high&quot;</code>, <code>&quot;medium&quot;</code>, <code>&quot;low&quot;</code></td>
</tr>
<tr>
  <td><code>issue_id</code></td>
  <td>str</td>
  <td>No</td>
  <td>Stable identifier for lifecycle tracking. Strongly recommended</td>
</tr>
<tr>
  <td><code>category</code></td>
  <td>str</td>
  <td>No</td>
  <td>Classification: <code>&quot;permissions&quot;</code>, <code>&quot;connectivity&quot;</code>, <code>&quot;configuration&quot;</code>, <code>&quot;data_quality&quot;</code>, <code>&quot;rate_limit&quot;</code>, <code>&quot;other&quot;</code></td>
</tr>
<tr>
  <td><code>context</code></td>
  <td>dict</td>
  <td>No</td>
  <td>Arbitrary debugging data — API names, error codes, timestamps</td>
</tr>
<tr>
  <td><code>occurrence_count</code></td>
  <td>int</td>
  <td>No</td>
  <td>Agent-tracked count of how many times this has happened</td>
</tr>
</tbody>
</table></div>
<p><strong>Resolve an issue:</strong></p>
<div class="code-block"><span class="code-lang">python</span><pre><code class="language-python">agent.resolve_issue(
    &quot;CRM API recovered — returning 200 again&quot;,
    issue_id=&quot;crm-403&quot;,
)
</code></pre></div>
<div class="table-wrapper"><table>
<thead>
<tr>
  <th>Parameter</th>
  <th>Type</th>
  <th>Required</th>
  <th>Description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><code>summary</code></td>
  <td>str</td>
  <td><strong>Yes</strong></td>
  <td>Resolution message</td>
</tr>
<tr>
  <td><code>issue_id</code></td>
  <td>str</td>
  <td>No</td>
  <td>Must match the original report for lifecycle tracking</td>
</tr>
</tbody>
</table></div>
<h3 id="53-issues-vs-task-failures-when-to-use-which">5.3 Issues vs. task failures — when to use which <a class="heading-anchor" href="#53-issues-vs-task-failures-when-to-use-which" aria-label="Link to this section">#</a></h3>
<p>This is the most common source of confusion. Here's the distinction:</p>
<div class="table-wrapper"><table>
<thead>
<tr>
  <th></th>
  <th>Task failure</th>
  <th>Agent issue</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>Scope</strong></td>
  <td>One specific task</td>
  <td>The agent overall</td>
</tr>
<tr>
  <td><strong>Trigger</strong></td>
  <td>Exception inside <code>agent.task()</code></td>
  <td>Agent detects an ongoing problem</td>
</tr>
<tr>
  <td><strong>Lifecycle</strong></td>
  <td>Automatic — emitted when the task's context manager catches an exception</td>
  <td>Manual — you call <code>report_issue()</code> and <code>resolve_issue()</code></td>
</tr>
<tr>
  <td><strong>Duration</strong></td>
  <td>Instantaneous — a single failed attempt</td>
  <td>Persistent — stays until resolved</td>
</tr>
<tr>
  <td><strong>Example</strong></td>
  <td>&quot;Task #4801 failed: ConnectionError&quot;</td>
  <td>&quot;CRM API has been returning 403 for the last 30 minutes&quot;</td>
</tr>
<tr>
  <td><strong>Dashboard</strong></td>
  <td>Red dot on the task row, <code>task_failed</code> in Activity Stream</td>
  <td>Red badge on the agent card, Issues table in Pipeline tab</td>
</tr>
</tbody>
</table></div>
<p><strong>Rule of thumb:</strong> If the problem would go away by retrying the task, it's a task failure. If the problem persists across multiple tasks, it's an issue.</p>
<h3 id="54-finding-where-to-add-issue-reporting">5.4 Finding WHERE to add issue reporting <a class="heading-anchor" href="#54-finding-where-to-add-issue-reporting" aria-label="Link to this section">#</a></h3>
<p>Look for code that detects persistent problems — not individual errors, but patterns:</p>
<ol>
<li><p><strong>Retry exhaustion with circuit-breaker logic:</strong></p>
<div class="code-block"><span class="code-lang">python</span><pre><code class="language-python">if consecutive_failures &gt;= FAILURE_THRESHOLD:
    self.circuit_open = True                     # ← issue point
    log.warning(&quot;Circuit breaker opened for CRM API&quot;)
</code></pre></div>
</li>
<li><p><strong>Health check failures:</strong></p>
<div class="code-block"><span class="code-lang">python</span><pre><code class="language-python">def health_check(self):
    if not self.api_client.ping():
        log.warning(&quot;API health check failed&quot;)   # ← issue point
</code></pre></div>
</li>
<li><p><strong>Rate limit detection:</strong></p>
<div class="code-block"><span class="code-lang">python</span><pre><code class="language-python">if response.status_code == 429:
    self.rate_limited = True                      # ← issue point
    self.backoff_until = time.time() + retry_after
</code></pre></div>
</li>
<li><p><strong>Data quality checks:</strong></p>
<div class="code-block"><span class="code-lang">python</span><pre><code class="language-python">if invalid_records / total_records &gt; 0.10:
    log.warning(&quot;10%+ records invalid&quot;)           # ← issue point
</code></pre></div>
</li>
<li><p><strong>Configuration problems detected at runtime:</strong></p>
<div class="code-block"><span class="code-lang">python</span><pre><code class="language-python">if not os.environ.get(&quot;API_KEY&quot;):
    log.error(&quot;API_KEY not configured&quot;)            # ← issue point
</code></pre></div>
</li>
</ol>
<h3 id="55-integration-pattern">5.5 Integration pattern <a class="heading-anchor" href="#55-integration-pattern" aria-label="Link to this section">#</a></h3>
<p>The typical pattern has three parts: detect, report, and resolve.</p>
<div class="code-block"><span class="code-lang">python</span><pre><code class="language-python"># Detection — when the agent discovers a problem:
def on_api_error(self, error, api_name):
    self._error_counts[api_name] = self._error_counts.get(api_name, 0) + 1

    if self._error_counts[api_name] &gt;= 3:
        hiveloop_agent = get_hiveloop_agent(self.agent_name)
        if hiveloop_agent:
            try:
                hiveloop_agent.report_issue(
                    summary=f&quot;{api_name} consistently failing: {error}&quot;,
                    severity=&quot;high&quot;,
                    issue_id=f&quot;api-error-{api_name}&quot;,
                    category=&quot;connectivity&quot;,
                    context={
                        &quot;api&quot;: api_name,
                        &quot;error&quot;: str(error),
                        &quot;consecutive_failures&quot;: self._error_counts[api_name],
                    },
                    occurrence_count=self._error_counts[api_name],
                )
            except Exception:
                pass

# Resolution — when the problem goes away:
def on_api_success(self, api_name):
    if self._error_counts.get(api_name, 0) &gt;= 3:
        hiveloop_agent = get_hiveloop_agent(self.agent_name)
        if hiveloop_agent:
            try:
                hiveloop_agent.resolve_issue(
                    f&quot;{api_name} recovered&quot;,
                    issue_id=f&quot;api-error-{api_name}&quot;,
                )
            except Exception:
                pass
    self._error_counts[api_name] = 0
</code></pre></div>
<h3 id="56-severity-guidelines">5.6 Severity guidelines <a class="heading-anchor" href="#56-severity-guidelines" aria-label="Link to this section">#</a></h3>
<div class="table-wrapper"><table>
<thead>
<tr>
  <th>Severity</th>
  <th>When to use</th>
  <th>Example</th>
</tr>
</thead>
<tbody>
<tr>
  <td><code>critical</code></td>
  <td>Agent cannot function at all</td>
  <td>&quot;No API key configured&quot;, &quot;Database unreachable&quot;</td>
</tr>
<tr>
  <td><code>high</code></td>
  <td>Agent can work but a major capability is degraded</td>
  <td>&quot;CRM API returning 403&quot;, &quot;LLM rate limited&quot;</td>
</tr>
<tr>
  <td><code>medium</code></td>
  <td>Agent works but output quality is reduced</td>
  <td>&quot;Enrichment data stale&quot;, &quot;Fallback model in use&quot;</td>
</tr>
<tr>
  <td><code>low</code></td>
  <td>Informational — something the ops team should know</td>
  <td>&quot;Cache miss rate high&quot;, &quot;Slow response times&quot;</td>
</tr>
</tbody>
</table></div>
<h3 id="57-the-issue_id-pattern">5.7 The <code>issue_id</code> pattern <a class="heading-anchor" href="#57-the-issue_id-pattern" aria-label="Link to this section">#</a></h3>
<p>Always use <code>issue_id</code> for issues that can be resolved. Without it, deduplication is hash-based on the summary text, which is fragile.</p>
<p><strong>Good <code>issue_id</code> patterns:</strong></p>
<div class="code-block"><span class="code-lang">python</span><pre><code class="language-python">issue_id=&quot;crm-api-403&quot;          # API + error code
issue_id=&quot;rate-limit-openai&quot;    # category + service
issue_id=f&quot;data-quality-{table}&quot;  # category + entity
</code></pre></div>
<p><strong>Avoid:</strong></p>
<div class="code-block"><span class="code-lang">python</span><pre><code class="language-python">issue_id=str(uuid.uuid4())     # unique per occurrence — defeats dedup
issue_id=&quot;error&quot;               # too generic — all issues collapse into one
</code></pre></div>
<h3 id="58-loopcore-example">5.8 loopCore example <a class="heading-anchor" href="#58-loopcore-example" aria-label="Link to this section">#</a></h3>
<p>In loopCore, the issue reporting tool (<code>report_issue</code>) is already a first-class agent capability. The agent calls it when it detects problems with its tools:</p>
<p><strong><code>issue_tools.py</code> — when a tool consistently fails:</strong></p>
<div class="code-block"><span class="code-lang">python</span><pre><code class="language-python">def on_tool_failure(agent_name, tool_name, error, consecutive_count):
    hiveloop_agent = get_hiveloop_agent(agent_name)
    if hiveloop_agent and consecutive_count &gt;= 3:
        try:
            hiveloop_agent.report_issue(
                summary=f&quot;Tool '{tool_name}' failing: {error}&quot;,
                severity=&quot;high&quot;,
                issue_id=f&quot;tool-failure-{tool_name}&quot;,
                category=&quot;connectivity&quot;,
                context={
                    &quot;tool&quot;: tool_name,
                    &quot;error&quot;: str(error),
                    &quot;consecutive_failures&quot;: consecutive_count,
                },
                occurrence_count=consecutive_count,
            )
        except Exception:
            pass
</code></pre></div>
<p><strong>Resolution — when the tool succeeds again:</strong></p>
<div class="code-block"><span class="code-lang">python</span><pre><code class="language-python">def on_tool_success(agent_name, tool_name):
    hiveloop_agent = get_hiveloop_agent(agent_name)
    if hiveloop_agent:
        try:
            hiveloop_agent.resolve_issue(
                f&quot;Tool '{tool_name}' recovered&quot;,
                issue_id=f&quot;tool-failure-{tool_name}&quot;,
            )
        except Exception:
            pass
</code></pre></div>
<h3 id="59-dashboard-impact">5.9 Dashboard impact <a class="heading-anchor" href="#59-dashboard-impact" aria-label="Link to this section">#</a></h3>
<div class="table-wrapper"><table>
<thead>
<tr>
  <th>Element</th>
  <th>What appears</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>Agent card</strong></td>
  <td>Red issue badge (e.g. &quot;● 1 issue&quot;) — visible in The Hive</td>
</tr>
<tr>
  <td><strong>Pipeline tab</strong></td>
  <td>Active Issues table with severity, category, occurrence count</td>
</tr>
<tr>
  <td><strong>Activity Stream</strong></td>
  <td>Issue events with warning icons; resolved issues also appear</td>
</tr>
<tr>
  <td><strong>Stats</strong></td>
  <td><code>active_issues</code> count in agent stats</td>
</tr>
</tbody>
</table></div>
<p>Issues <strong>persist until explicitly resolved.</strong> If you report an issue and never resolve it, the red badge stays on the agent card permanently. This is by design — persistent problems should remain visible until someone addresses them.</p>
<hr />
<h2 id="6-queue-snapshots-agentqueue_snapshot">6. Queue Snapshots — <code>agent.queue_snapshot()</code> <a class="heading-anchor" href="#6-queue-snapshots-agentqueue_snapshot" aria-label="Link to this section">#</a></h2>
<h3 id="61-what-it-does">6.1 What it does <a class="heading-anchor" href="#61-what-it-does" aria-label="Link to this section">#</a></h3>
<p><code>agent.queue_snapshot()</code> reports the current state of the agent's work queue. This gives the dashboard visibility into how much work is pending, how old the oldest item is, and what's currently being processed.</p>
<h3 id="62-the-api">6.2 The API <a class="heading-anchor" href="#62-the-api" aria-label="Link to this section">#</a></h3>
<div class="code-block"><span class="code-lang">python</span><pre><code class="language-python">agent.queue_snapshot(
    depth=4,
    oldest_age_seconds=120,
    items=[
        {&quot;id&quot;: &quot;job-001&quot;, &quot;priority&quot;: &quot;high&quot;, &quot;source&quot;: &quot;human&quot;,
         &quot;summary&quot;: &quot;Review contract&quot;, &quot;queued_at&quot;: &quot;2026-02-12T14:28:00Z&quot;},
        {&quot;id&quot;: &quot;job-002&quot;, &quot;priority&quot;: &quot;normal&quot;, &quot;source&quot;: &quot;webhook&quot;,
         &quot;summary&quot;: &quot;Process CRM update&quot;, &quot;queued_at&quot;: &quot;2026-02-12T14:29:00Z&quot;},
    ],
    processing={&quot;id&quot;: &quot;job-003&quot;, &quot;summary&quot;: &quot;Sending email&quot;,
                &quot;started_at&quot;: &quot;2026-02-12T14:29:30Z&quot;, &quot;elapsed_ms&quot;: 4500},
)
</code></pre></div>
<div class="table-wrapper"><table>
<thead>
<tr>
  <th>Parameter</th>
  <th>Type</th>
  <th>Required</th>
  <th>Description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><code>depth</code></td>
  <td>int</td>
  <td><strong>Yes</strong></td>
  <td>Number of items in the queue</td>
</tr>
<tr>
  <td><code>oldest_age_seconds</code></td>
  <td>int</td>
  <td>No</td>
  <td>Age of the oldest queued item</td>
</tr>
<tr>
  <td><code>items</code></td>
  <td>list[dict]</td>
  <td>No</td>
  <td>The actual queue entries (max ~10 for readability)</td>
</tr>
<tr>
  <td><code>processing</code></td>
  <td>dict</td>
  <td>No</td>
  <td>What's currently being processed</td>
</tr>
</tbody>
</table></div>
<p><strong>Each item in <code>items</code>:</strong></p>
<div class="table-wrapper"><table>
<thead>
<tr>
  <th>Field</th>
  <th>Type</th>
  <th>Description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><code>id</code></td>
  <td>str</td>
  <td>Item identifier</td>
</tr>
<tr>
  <td><code>priority</code></td>
  <td>str</td>
  <td><code>&quot;low&quot;</code>, <code>&quot;normal&quot;</code>, <code>&quot;high&quot;</code>, <code>&quot;urgent&quot;</code></td>
</tr>
<tr>
  <td><code>source</code></td>
  <td>str</td>
  <td>Where the item came from (<code>&quot;human&quot;</code>, <code>&quot;webhook&quot;</code>, <code>&quot;scheduled&quot;</code>, <code>&quot;agent&quot;</code>)</td>
</tr>
<tr>
  <td><code>summary</code></td>
  <td>str</td>
  <td>What the item is about</td>
</tr>
<tr>
  <td><code>queued_at</code></td>
  <td>str</td>
  <td>ISO 8601 timestamp of when it was queued</td>
</tr>
</tbody>
</table></div>
<h3 id="63-two-ways-to-report-queue-state">6.3 Two ways to report queue state <a class="heading-anchor" href="#63-two-ways-to-report-queue-state" aria-label="Link to this section">#</a></h3>
<p><strong>Option A — Automatic via <code>queue_provider</code> callback (recommended):</strong></p>
<p>Register a callback when creating the agent. It's called every heartbeat cycle:</p>
<div class="code-block"><span class="code-lang">python</span><pre><code class="language-python">agent = hb.agent(
    &quot;my-agent&quot;,
    type=&quot;processor&quot;,
    queue_provider=lambda: {
        &quot;depth&quot;: work_queue.qsize(),
        &quot;oldest_age_seconds&quot;: get_oldest_age(),
        &quot;items&quot;: [
            {&quot;id&quot;: item.id, &quot;priority&quot;: item.priority, &quot;summary&quot;: item.summary}
            for item in list(work_queue.queue)[:10]
        ],
    },
)
</code></pre></div>
<p>This is fire-and-forget — once registered, it reports queue state automatically every heartbeat (default 30 seconds).</p>
<p><strong>Option B — Explicit calls (for non-standard queues):</strong></p>
<p>Call <code>agent.queue_snapshot()</code> directly at any point:</p>
<div class="code-block"><span class="code-lang">python</span><pre><code class="language-python">hiveloop_agent = get_hiveloop_agent(agent_name)
if hiveloop_agent:
    try:
        hiveloop_agent.queue_snapshot(
            depth=len(pending_items),
            oldest_age_seconds=oldest_age,
            items=[...],
        )
    except Exception:
        pass
</code></pre></div>
<p>Use Option B when:</p>
<ul>
<li>The queue state is expensive to compute and you don't want to do it every heartbeat</li>
<li>The queue is external (a database table, a Redis list, an SQS queue) and requires async access</li>
<li>You want to report queue state at specific moments (e.g., after each dequeue)</li>
</ul>
<h3 id="64-finding-where-to-add-queue-snapshots">6.4 Finding WHERE to add queue snapshots <a class="heading-anchor" href="#64-finding-where-to-add-queue-snapshots" aria-label="Link to this section">#</a></h3>
<p>If your agent processes a work queue, the integration point depends on how the queue is structured:</p>
<ol>
<li><p><strong>In-memory queue (threading.Queue, asyncio.Queue, list):</strong></p>
<div class="code-block"><span class="code-lang">python</span><pre><code class="language-python"># Option A — callback (best):
agent = hb.agent(&quot;worker&quot;, queue_provider=lambda: {&quot;depth&quot;: q.qsize()})

# Option B — explicit, after each dequeue:
item = queue.get()
agent.queue_snapshot(depth=queue.qsize())
</code></pre></div>
</li>
<li><p><strong>Database-backed queue (polling a table):</strong></p>
<div class="code-block"><span class="code-lang">python</span><pre><code class="language-python"># Report after each poll cycle:
pending = db.query(&quot;SELECT * FROM jobs WHERE status = 'pending'&quot;)
agent.queue_snapshot(
    depth=len(pending),
    items=[{&quot;id&quot;: j.id, &quot;summary&quot;: j.description} for j in pending[:10]],
)
</code></pre></div>
</li>
<li><p><strong>External message queue (SQS, RabbitMQ, Redis):</strong></p>
<div class="code-block"><span class="code-lang">python</span><pre><code class="language-python"># Report periodically or after each message:
approx_depth = sqs_client.get_queue_attributes(QueueUrl=url,
    AttributeNames=[&quot;ApproximateNumberOfMessages&quot;])
agent.queue_snapshot(depth=int(approx_depth))
</code></pre></div>
</li>
<li><p><strong>No explicit queue, but work arrives via events/callbacks:</strong></p>
<div class="code-block"><span class="code-lang">python</span><pre><code class="language-python"># Maintain a counter:
class Agent:
    def __init__(self):
        self._pending_count = 0

    def on_new_event(self, event):
        self._pending_count += 1

    def on_event_processed(self, event):
        self._pending_count -= 1

    def get_queue_depth(self):
        return self._pending_count

# Register callback:
agent = hb.agent(&quot;my-agent&quot;,
    queue_provider=lambda: {&quot;depth&quot;: my_agent.get_queue_depth()})
</code></pre></div>
</li>
</ol>
<h3 id="65-loopcore-example">6.5 loopCore example <a class="heading-anchor" href="#65-loopcore-example" aria-label="Link to this section">#</a></h3>
<p>In loopCore, agents process events from an inbox. The queue state is the pending events list:</p>
<p><strong>Agent registration with queue provider:</strong></p>
<div class="code-block"><span class="code-lang">python</span><pre><code class="language-python">hiveloop_agent = hb.agent(
    agent.name,
    type=agent.type,
    framework=&quot;loopcore&quot;,
    queue_provider=lambda: {
        &quot;depth&quot;: len(agent.inbox.pending),
        &quot;oldest_age_seconds&quot;: agent.inbox.oldest_age(),
        &quot;items&quot;: [
            {
                &quot;id&quot;: evt.id,
                &quot;priority&quot;: evt.priority,
                &quot;source&quot;: evt.source,
                &quot;summary&quot;: evt.summary[:100],
            }
            for evt in agent.inbox.pending[:10]
        ],
    },
)
</code></pre></div>
<p>The <code>queue_provider</code> callback is called every heartbeat (30 seconds). No explicit <code>queue_snapshot()</code> calls needed — the SDK handles it.</p>
<h3 id="66-dashboard-impact">6.6 Dashboard impact <a class="heading-anchor" href="#66-dashboard-impact" aria-label="Link to this section">#</a></h3>
<div class="table-wrapper"><table>
<thead>
<tr>
  <th>Element</th>
  <th>What appears</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>Agent card</strong></td>
  <td>Queue badge (e.g. &quot;Q:4&quot; in blue, &quot;Q:8&quot; in amber if &gt;5)</td>
</tr>
<tr>
  <td><strong>Pipeline tab</strong></td>
  <td>Queue table with item details (ID, priority, source, summary, age)</td>
</tr>
<tr>
  <td><strong>Agent stats</strong></td>
  <td><code>queue_depth</code> field in <code>stats_1h</code> response</td>
</tr>
<tr>
  <td><strong>Activity Stream</strong></td>
  <td><code>queue_snapshot</code> events under the &quot;pipeline&quot; filter</td>
</tr>
</tbody>
</table></div>
<hr />
<h2 id="7-retries-taskretry">7. Retries — <code>task.retry()</code> <a class="heading-anchor" href="#7-retries-taskretry" aria-label="Link to this section">#</a></h2>
<h3 id="71-what-it-does">7.1 What it does <a class="heading-anchor" href="#71-what-it-does" aria-label="Link to this section">#</a></h3>
<p><code>task.retry()</code> records when an agent retries a failed operation. This makes retry patterns visible — how many retries happen, what causes them, and how much time is lost to backoff.</p>
<h3 id="72-the-api">7.2 The API <a class="heading-anchor" href="#72-the-api" aria-label="Link to this section">#</a></h3>
<div class="code-block"><span class="code-lang">python</span><pre><code class="language-python">task.retry(
    &quot;Retrying after CRM API timeout&quot;,
    attempt=2,
    backoff_seconds=4.0,
)
</code></pre></div>
<div class="table-wrapper"><table>
<thead>
<tr>
  <th>Parameter</th>
  <th>Type</th>
  <th>Required</th>
  <th>Description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><code>summary</code></td>
  <td>str</td>
  <td><strong>Yes</strong></td>
  <td>What's being retried and why</td>
</tr>
<tr>
  <td><code>attempt</code></td>
  <td>int</td>
  <td>No</td>
  <td>Attempt number (1-based)</td>
</tr>
<tr>
  <td><code>backoff_seconds</code></td>
  <td>float</td>
  <td>No</td>
  <td>How long before the next attempt</td>
</tr>
</tbody>
</table></div>
<h3 id="73-finding-where-to-add-retries">7.3 Finding WHERE to add retries <a class="heading-anchor" href="#73-finding-where-to-add-retries" aria-label="Link to this section">#</a></h3>
<p>Search for retry patterns in your code:</p>
<ol>
<li><p><strong>Explicit retry loops:</strong></p>
<div class="code-block"><span class="code-lang">python</span><pre><code class="language-python">for attempt in range(max_retries):
    try:
        result = call_api()
        break
    except TransientError:
        time.sleep(2 ** attempt)      # ← retry point
</code></pre></div>
</li>
<li><p><strong>Retry decorators (tenacity, backoff):</strong></p>
<div class="code-block"><span class="code-lang">python</span><pre><code class="language-python">@retry(stop=stop_after_attempt(3), wait=wait_exponential())
def call_api():                        # ← each retry is invisible without instrumentation
    return api_client.get(url)
</code></pre></div>
</li>
<li><p><strong>Conditional re-execution:</strong></p>
<div class="code-block"><span class="code-lang">python</span><pre><code class="language-python">while not success and retries &lt; MAX:
    success = try_operation()
    if not success:
        retries += 1                   # ← retry point
</code></pre></div>
</li>
<li><p><strong>Queue-based retry (re-enqueue on failure):</strong></p>
<div class="code-block"><span class="code-lang">python</span><pre><code class="language-python">except ProcessingError:
    item.retry_count += 1
    queue.put(item)                    # ← retry point
</code></pre></div>
</li>
</ol>
<h3 id="74-integration-pattern">7.4 Integration pattern <a class="heading-anchor" href="#74-integration-pattern" aria-label="Link to this section">#</a></h3>
<div class="code-block"><span class="code-lang">python</span><pre><code class="language-python">from myproject.observability import get_current_task

for attempt in range(1, max_retries + 1):
    try:
        result = call_external_api()
        break
    except TransientError as e:
        if attempt &lt; max_retries:
            backoff = 2 ** attempt
            task = get_current_task()
            if task:
                try:
                    task.retry(
                        f&quot;Retrying after {type(e).__name__}: {e}&quot;,
                        attempt=attempt,
                        backoff_seconds=backoff,
                    )
                except Exception:
                    pass
            time.sleep(backoff)
        else:
            raise  # final attempt — let the exception propagate
</code></pre></div>
<p><strong>For tenacity-based retries</strong>, use a callback:</p>
<div class="code-block"><span class="code-lang">python</span><pre><code class="language-python">import tenacity

def on_retry(retry_state):
    task = get_current_task()
    if task:
        try:
            task.retry(
                f&quot;Retry attempt {retry_state.attempt_number}: {retry_state.outcome.exception()}&quot;,
                attempt=retry_state.attempt_number,
                backoff_seconds=retry_state.next_action.sleep if hasattr(retry_state.next_action, 'sleep') else None,
            )
        except Exception:
            pass

@tenacity.retry(
    stop=tenacity.stop_after_attempt(3),
    wait=tenacity.wait_exponential(),
    before_sleep=on_retry,
)
def call_api():
    return api_client.get(url)
</code></pre></div>
<h3 id="75-loopcore-example">7.5 loopCore example <a class="heading-anchor" href="#75-loopcore-example" aria-label="Link to this section">#</a></h3>
<p>In loopCore, retries happen when tool execution fails and the agent decides to try again:</p>
<p><strong><code>loop.py</code> — after a failed tool execution:</strong></p>
<div class="code-block"><span class="code-lang">python</span><pre><code class="language-python">if should_retry and attempt &lt; max_retries:
    task = get_current_task()
    if task:
        try:
            task.retry(
                f&quot;Retrying tool '{tool_name}' after failure: {error}&quot;,
                attempt=attempt,
                backoff_seconds=backoff,
            )
        except Exception:
            pass
    time.sleep(backoff)
</code></pre></div>
<p><strong><code>agent.py</code> — when a failed run creates a retry TODO:</strong></p>
<div class="code-block"><span class="code-lang">python</span><pre><code class="language-python">task = get_current_task()
if task:
    try:
        task.retry(
            f&quot;Scheduling retry: {failure_reason}&quot;,
            attempt=retry_count,
        )
    except Exception:
        pass
</code></pre></div>
<h3 id="76-dashboard-impact">7.6 Dashboard impact <a class="heading-anchor" href="#76-dashboard-impact" aria-label="Link to this section">#</a></h3>
<div class="table-wrapper"><table>
<thead>
<tr>
  <th>Element</th>
  <th>What appears</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>Timeline</strong></td>
  <td>Retry nodes showing attempt count and backoff</td>
</tr>
<tr>
  <td><strong>Activity Stream</strong></td>
  <td><code>retry_started</code> events with attempt number</td>
</tr>
</tbody>
</table></div>
<p>Retries help you answer: &quot;Is this agent spending most of its time retrying? Which operation causes the most retries? Is the backoff strategy appropriate?&quot;</p>
<hr />
<h2 id="8-tool-execution-tracking-agenttrack_context">8. Tool Execution Tracking — <code>agent.track_context()</code> <a class="heading-anchor" href="#8-tool-execution-tracking-agenttrack_context" aria-label="Link to this section">#</a></h2>
<h3 id="81-the-problem">8.1 The problem <a class="heading-anchor" href="#81-the-problem" aria-label="Link to this section">#</a></h3>
<p>Most agentic frameworks follow a loop: the LLM reasons, decides which tool(s) to call, then the framework executes those tools one at a time. A single turn may have zero or more tool calls. The tool name is determined at runtime by the LLM — you don't know at code-definition time which tool will be called.</p>
<p>Without instrumentation, tool execution is invisible on the dashboard. You see the LLM call (via <code>task.llm_call()</code>) and the task lifecycle, but the actual work — searching a CRM, sending an email, querying a database — is a black box.</p>
<h3 id="82-the-method">8.2 The method <a class="heading-anchor" href="#82-the-method" aria-label="Link to this section">#</a></h3>
<p><code>agent.track_context(tool_name)</code> is a context manager that wraps any code block and emits <code>action_started</code> + <code>action_completed</code> (or <code>action_failed</code>) events automatically.</p>
<div class="code-block"><span class="code-lang">python</span><pre><code class="language-python">with agent.track_context(tool_call.name) as ctx:
    result = execute_tool(tool_call.name, tool_call.args)
</code></pre></div>
<p>This is the right choice over the alternatives:</p>
<div class="table-wrapper"><table>
<thead>
<tr>
  <th>Method</th>
  <th>Why it's not ideal for tool dispatch</th>
</tr>
</thead>
<tbody>
<tr>
  <td><code>@agent.track(&quot;name&quot;)</code></td>
  <td>Decorator — requires the tool name at function definition time. In agentic loops, the LLM picks the tool at runtime</td>
</tr>
<tr>
  <td><code>task.event(&quot;tool_used&quot;, ...)</code></td>
  <td>Raw event — no automatic duration, no start/complete pairing, no nesting</td>
</tr>
<tr>
  <td><code>task.llm_call()</code></td>
  <td>Wrong scope — for the LLM API call itself, not the tool execution after it</td>
</tr>
</tbody>
</table></div>
<h3 id="83-what-you-get-automatically">8.3 What you get automatically <a class="heading-anchor" href="#83-what-you-get-automatically" aria-label="Link to this section">#</a></h3>
<p>Each <code>track_context()</code> block gives you:</p>
<div class="table-wrapper"><table>
<thead>
<tr>
  <th>Feature</th>
  <th>How</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>Tool name on timeline</strong></td>
  <td>Passed as the string argument — shown on the blue action node</td>
</tr>
<tr>
  <td><strong>Duration</strong></td>
  <td>Automatic — measured from enter to exit</td>
</tr>
<tr>
  <td><strong>Success/failure</strong></td>
  <td>Automatic — exceptions propagate but get recorded as <code>action_failed</code></td>
</tr>
<tr>
  <td><strong>Nesting</strong></td>
  <td>Automatic — if you're already inside a tracked action, tool calls become children in the action tree</td>
</tr>
<tr>
  <td><strong>Function name</strong></td>
  <td>Not available (unlike <code>@agent.track()</code> which captures <code>fn.__qualname__</code>). Use <code>ctx.set_payload()</code> if needed</td>
</tr>
</tbody>
</table></div>
<h3 id="84-the-full-turn-pattern">8.4 The full turn pattern <a class="heading-anchor" href="#84-the-full-turn-pattern" aria-label="Link to this section">#</a></h3>
<p>A typical agentic turn has two parts: the LLM call and the tool execution(s). Here's how to instrument both:</p>
<div class="code-block"><span class="code-lang">python</span><pre><code class="language-python">import time
from myproject.observability import get_current_task

def run_turn(hiveloop_agent, messages, tool_definitions):
    # 1. LLM call — the agent reasons and decides what tools to use
    start = time.perf_counter()
    response = llm.chat(messages, tools=tool_definitions)
    elapsed = (time.perf_counter() - start) * 1000

    task = get_current_task()
    if task:
        try:
            task.llm_call(
                &quot;agent_turn&quot;,
                model=response.model,
                tokens_in=response.usage.input_tokens,
                tokens_out=response.usage.output_tokens,
                duration_ms=round(elapsed),
            )
        except Exception:
            pass

    # 2. Tool execution — zero or more per turn
    for tool_call in response.tool_calls:
        with hiveloop_agent.track_context(tool_call.name) as ctx:
            result = tool_registry.execute(tool_call.name, tool_call.arguments)
</code></pre></div>
<p>On the dashboard timeline, this produces:</p>
<div class="code-block"><pre><code>[■ agent_turn] → [● search_crm] → [● score_lead] → [■ agent_turn] → [● send_email]
  claude-sonnet      0.8s              0.2s            claude-sonnet      1.1s
</code></pre></div>
<p>Purple LLM nodes for the reasoning, blue action nodes for each tool, all in sequence with durations.</p>
<h3 id="85-attaching-tool-metadata">8.5 Attaching tool metadata <a class="heading-anchor" href="#85-attaching-tool-metadata" aria-label="Link to this section">#</a></h3>
<p>Use <code>ctx.set_payload()</code> inside the context manager to add tool arguments, results, or other data. This shows up when you click the action node on the timeline:</p>
<div class="code-block"><span class="code-lang">python</span><pre><code class="language-python">with hiveloop_agent.track_context(tool_call.name) as ctx:
    result = tool_registry.execute(tool_call.name, tool_call.arguments)
    ctx.set_payload({
        &quot;args&quot;: {k: str(v)[:100] for k, v in tool_call.arguments.items()},
        &quot;result_preview&quot;: str(result)[:200],
    })
</code></pre></div>
<p><strong>Important:</strong> <code>set_payload()</code> adds data to the <code>action_completed</code> event. If the tool throws before <code>set_payload()</code> is reached, the <code>action_failed</code> event still captures the exception automatically — you don't need to handle that case.</p>
<h3 id="86-turns-with-zero-tool-calls">8.6 Turns with zero tool calls <a class="heading-anchor" href="#86-turns-with-zero-tool-calls" aria-label="Link to this section">#</a></h3>
<p>If the LLM decides not to call any tools (e.g., a final answer turn), the <code>for tool_call in response.tool_calls</code> loop simply doesn't execute. No action events are emitted — only the LLM call. This is correct: the timeline shows a reasoning node with no tool execution, which tells the operator &quot;the agent answered without using tools.&quot;</p>
<h3 id="87-error-handling">8.7 Error handling <a class="heading-anchor" href="#87-error-handling" aria-label="Link to this section">#</a></h3>
<p><code>track_context()</code> never swallows exceptions. If a tool throws, the exception propagates normally — but a red <code>action_failed</code> node appears on the timeline with the exception type and message:</p>
<div class="code-block"><span class="code-lang">python</span><pre><code class="language-python">with hiveloop_agent.track_context(&quot;crm_search&quot;) as ctx:
    result = crm_client.search(query)  # raises ConnectionError
# ConnectionError propagates — but the timeline now shows:
#   [● crm_search] (red, failed)
#     exception_type: ConnectionError
#     exception_message: Connection refused
#     duration: 2.1s
</code></pre></div>
<p>If you want to catch the error and continue (e.g., to try the next tool), wrap the context manager in your own try/except:</p>
<div class="code-block"><span class="code-lang">python</span><pre><code class="language-python">for tool_call in response.tool_calls:
    try:
        with hiveloop_agent.track_context(tool_call.name) as ctx:
            result = tool_registry.execute(tool_call.name, tool_call.arguments)
    except ToolError as e:
        results.append({&quot;error&quot;: str(e)})
        continue
</code></pre></div>
<p>The failed action still appears on the timeline (red node), but execution continues.</p>
<h3 id="88-nested-tool-calls">8.8 Nested tool calls <a class="heading-anchor" href="#88-nested-tool-calls" aria-label="Link to this section">#</a></h3>
<p>If a tool internally calls another tool (or another tracked function), the nesting is captured automatically:</p>
<div class="code-block"><span class="code-lang">python</span><pre><code class="language-python">with hiveloop_agent.track_context(&quot;process_lead&quot;) as ctx:
    # This tool internally calls sub-tools:
    with hiveloop_agent.track_context(&quot;crm_search&quot;) as ctx2:
        record = crm_client.search(lead.email)
    with hiveloop_agent.track_context(&quot;score_lead&quot;) as ctx3:
        score = scorer.score(lead, record)
</code></pre></div>
<p>The timeline shows <code>process_lead</code> as a parent action with <code>crm_search</code> and <code>score_lead</code> as children, rendered as a branching tree.</p>
<h3 id="89-loopcore-example">8.9 loopCore example <a class="heading-anchor" href="#89-loopcore-example" aria-label="Link to this section">#</a></h3>
<p>In loopCore, tools are dispatched by the Phase 2 loop. Each tool call from the LLM response is executed sequentially:</p>
<div class="code-block"><span class="code-lang">python</span><pre><code class="language-python">from loop_core.observability import get_hiveloop_agent

# In the Phase 2 tool execution loop:
for tool_use in phase2_response.tool_calls:
    hiveloop_agent = get_hiveloop_agent(agent.name)
    if hiveloop_agent:
        with hiveloop_agent.track_context(tool_use.name) as ctx:
            result = tool_runner.execute(tool_use.name, tool_use.input)
            ctx.set_payload({&quot;result_preview&quot;: str(result)[:200]})
    else:
        result = tool_runner.execute(tool_use.name, tool_use.input)
</code></pre></div>
<p>If you don't want to duplicate the <code>execute</code> call, restructure:</p>
<div class="code-block"><span class="code-lang">python</span><pre><code class="language-python">for tool_use in phase2_response.tool_calls:
    hiveloop_agent = get_hiveloop_agent(agent.name)
    if hiveloop_agent:
        ctx_mgr = hiveloop_agent.track_context(tool_use.name)
    else:
        from contextlib import nullcontext
        ctx_mgr = nullcontext()

    with ctx_mgr as ctx:
        result = tool_runner.execute(tool_use.name, tool_use.input)
        if ctx and hasattr(ctx, 'set_payload'):
            ctx.set_payload({&quot;result_preview&quot;: str(result)[:200]})
</code></pre></div>
<h3 id="810-dashboard-impact">8.10 Dashboard impact <a class="heading-anchor" href="#810-dashboard-impact" aria-label="Link to this section">#</a></h3>
<div class="table-wrapper"><table>
<thead>
<tr>
  <th>Element</th>
  <th>What appears</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>Timeline</strong></td>
  <td>Blue action nodes for each tool call, with tool name and duration</td>
</tr>
<tr>
  <td><strong>Timeline (failed)</strong></td>
  <td>Red action node with exception type and message</td>
</tr>
<tr>
  <td><strong>Timeline (nested)</strong></td>
  <td>Parent-child branching for nested tool calls</td>
</tr>
<tr>
  <td><strong>Activity Stream</strong></td>
  <td><code>action_started</code>, <code>action_completed</code>, <code>action_failed</code> events</td>
</tr>
<tr>
  <td><strong>Activity Stream — &quot;action&quot; filter</strong></td>
  <td>Shows only tool execution events</td>
</tr>
</tbody>
</table></div>
<h3 id="811-validation-checklist">8.11 Validation checklist <a class="heading-anchor" href="#811-validation-checklist" aria-label="Link to this section">#</a></h3>
<ul>
<li>[ ] Trigger a turn with 1+ tool calls</li>
<li>[ ] <strong>Timeline</strong>: Blue action nodes appear with correct tool names</li>
<li>[ ] <strong>Timeline</strong>: Duration is shown on each node</li>
<li>[ ] Trigger a tool failure — verify red node with exception details</li>
<li>[ ] <strong>Activity Stream</strong>: <code>action_started</code> / <code>action_completed</code> events appear</li>
<li>[ ] Verify tool nodes appear between LLM call nodes in the correct sequence</li>
</ul>
<hr />
<h2 id="9-putting-it-all-together">9. Putting It All Together <a class="heading-anchor" href="#9-putting-it-all-together" aria-label="Link to this section">#</a></h2>
<p>Here's a complete example showing all methods integrated into a single agent task. This demonstrates how the events interleave to create a full operational narrative.</p>
<div class="code-block"><span class="code-lang">python</span><pre><code class="language-python">import hiveloop
from myproject.observability import get_current_task, get_hiveloop_agent

hb = hiveloop.init(api_key=&quot;hb_live_xxx&quot;, endpoint=&quot;http://localhost:8000&quot;)

agent = hb.agent(
    &quot;lead-qualifier&quot;,
    type=&quot;sales&quot;,
    queue_provider=lambda: {&quot;depth&quot;: work_queue.qsize()},    # queue snapshot (automatic)
)

def process_lead(lead):
    with agent.task(f&quot;lead-{lead.id}&quot;, project=&quot;sales-pipeline&quot;, type=&quot;lead_processing&quot;) as task:

        # Create a plan
        task.plan(&quot;Qualify and route lead&quot;, [
            &quot;Search CRM for existing record&quot;,
            &quot;Score lead against criteria&quot;,
            &quot;Enrich with external data&quot;,
            &quot;Route to sales rep&quot;,
        ])

        # Step 0: CRM search — tracked as a tool execution
        task.plan_step(0, &quot;started&quot;, &quot;Searching CRM&quot;)
        with agent.track_context(&quot;search_crm&quot;) as ctx:
            crm_record = search_crm(lead.email)
        task.plan_step(0, &quot;completed&quot;, f&quot;Found: {crm_record is not None}&quot;)

        # Step 1: Score lead — tracked as a tool execution
        task.plan_step(1, &quot;started&quot;, &quot;Scoring lead&quot;)
        with agent.track_context(&quot;score_lead&quot;) as ctx:
            score = score_lead(lead, crm_record)
        task.plan_step(1, &quot;completed&quot;, f&quot;Score: {score}&quot;)

        # Step 2: Enrich — with retry on failure, each attempt tracked
        task.plan_step(2, &quot;started&quot;, &quot;Enriching lead data&quot;)
        for attempt in range(1, 4):
            try:
                with agent.track_context(&quot;enrich_lead&quot;) as ctx:
                    enrichment = enrich_lead(lead)
                task.plan_step(2, &quot;completed&quot;, &quot;Enrichment succeeded&quot;)
                break
            except APITimeoutError as e:
                if attempt &lt; 3:
                    task.retry(f&quot;Enrichment API timeout&quot;, attempt=attempt, backoff_seconds=2.0)
                    time.sleep(2.0)
                else:
                    task.plan_step(2, &quot;failed&quot;, f&quot;Enrichment failed after 3 attempts&quot;)
                    # Report persistent issue
                    agent.report_issue(
                        summary=&quot;Enrichment API consistently timing out&quot;,
                        severity=&quot;high&quot;,
                        issue_id=&quot;enrichment-timeout&quot;,
                        category=&quot;connectivity&quot;,
                        context={&quot;api&quot;: &quot;clearbit&quot;, &quot;timeout_ms&quot;: 5000},
                    )

        # Step 3: Route — with escalation for low scores
        task.plan_step(3, &quot;started&quot;, &quot;Routing lead&quot;)
        if score &lt; 0.2:
            task.escalate(
                f&quot;Lead score {score:.2f} — below threshold, needs manual review&quot;,
                assigned_to=&quot;senior-sales&quot;,
            )
            task.plan_step(3, &quot;completed&quot;, &quot;Escalated to senior sales&quot;)
        else:
            with agent.track_context(&quot;assign_to_rep&quot;) as ctx:
                assign_to_rep(lead, score)
            task.plan_step(3, &quot;completed&quot;, f&quot;Assigned to {get_rep(score)}&quot;)

# Later, when the API recovers:
agent.resolve_issue(&quot;Enrichment API recovered&quot;, issue_id=&quot;enrichment-timeout&quot;)
</code></pre></div>
<p>On the dashboard, this task's timeline would show:</p>
<div class="code-block"><pre><code>PLAN: [■ Search CRM] [■ Score lead] [■ Enrich data] [■ Route lead]
            completed      completed    completed       completed

TIMELINE:
  [started] → [● search_crm 0.8s] → [● score_lead 0.2s]
     → [● enrich_lead ✗] → [retry #1] → [● enrich_lead ✗] → [retry #2]
     → [● enrich_lead 1.1s] → [▲ escalate] → [● assign_to_rep 0.3s]
     → [completed]
</code></pre></div>
<p>Blue <code>●</code> nodes are tool executions (from <code>track_context</code>), red <code>✗</code> marks failed attempts, amber <code>▲</code> is the escalation.</p>
<p>Plus:</p>
<ul>
<li>Agent card shows queue badge from <code>queue_provider</code></li>
<li>If enrichment fails 3 times, red issue badge appears on the agent card</li>
<li>Escalation event appears in Activity Stream under &quot;human&quot; filter</li>
<li>Retry nodes show attempt count and backoff timing</li>
<li>Each tool node shows duration — click to see payload details</li>
</ul>
<hr />
<h2 id="10-finding-integration-points-in-your-codebase">10. Finding Integration Points in Your Codebase <a class="heading-anchor" href="#10-finding-integration-points-in-your-codebase" aria-label="Link to this section">#</a></h2>
<p>Here's a systematic approach to finding where each method belongs in any agentic framework:</p>
<h3 id="101-use-this-prompt-with-your-llm">10.1 Use this prompt with your LLM <a class="heading-anchor" href="#101-use-this-prompt-with-your-llm" aria-label="Link to this section">#</a></h3>
<p>Ask Claude (or your preferred LLM) to analyze your codebase:</p>
<blockquote class="callout"><p><em>&quot;In [your codebase], trace the execution path from the agent's main loop to task completion. For each of the following, identify the file and line where it would go:</em></p>
<ol>
<li><em>Where does the agent create a plan or strategy? → <code>task.plan()</code></em></li>
<li><em>Where does the agent iterate through plan steps? → <code>task.plan_step()</code></em></li>
<li><em>Where does the agent decide to hand off to a human? → <code>task.escalate()</code></em></li>
<li><em>Where does the agent detect persistent problems (not single failures)? → <code>agent.report_issue()</code></em></li>
<li><em>Where is the work queue managed? → <code>agent.queue_snapshot()</code> or <code>queue_provider</code></em></li>
<li><em>Where does the agent retry after failure? → <code>task.retry()</code></em></li>
</ol>
<p><em>For each, give the file path, line number, and a code snippet showing the integration point.&quot;</em></p></blockquote>
<h3 id="102-search-patterns-by-framework-type">10.2 Search patterns by framework type <a class="heading-anchor" href="#102-search-patterns-by-framework-type" aria-label="Link to this section">#</a></h3>
<div class="table-wrapper"><table>
<thead>
<tr>
  <th>Framework type</th>
  <th>Plans</th>
  <th>Escalations</th>
  <th>Issues</th>
  <th>Queue</th>
  <th>Retries</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>Custom loop</strong></td>
  <td>Look for step lists in the main loop</td>
  <td>Look for threshold checks or &quot;give up&quot; logic</td>
  <td>Look for circuit breakers or error counters</td>
  <td>Look for the queue data structure</td>
  <td>Look for <code>for attempt in range</code> or <code>while</code> retry loops</td>
</tr>
<tr>
  <td><strong>LangChain</strong></td>
  <td>Agent's <code>plan()</code> method or chain-of-thought</td>
  <td><code>HumanApprovalCallbackHandler</code> usage</td>
  <td>Custom tool error handling</td>
  <td><code>CallbackManager</code> or custom queue</td>
  <td><code>RetryOutputParser</code> or custom retry logic</td>
</tr>
<tr>
  <td><strong>CrewAI</strong></td>
  <td>Crew's task planning phase</td>
  <td><code>human_input=True</code> on tasks</td>
  <td>Agent error handling callbacks</td>
  <td>Crew's task queue</td>
  <td>Built-in retry mechanisms</td>
</tr>
<tr>
  <td><strong>AutoGen</strong></td>
  <td>Multi-agent conversation planning</td>
  <td><code>human_input_mode=&quot;ALWAYS&quot;</code></td>
  <td>Agent failure handling</td>
  <td>Message queue between agents</td>
  <td><code>max_consecutive_auto_reply</code></td>
</tr>
<tr>
  <td><strong>FastAPI agent</strong></td>
  <td>Request processing pipeline</td>
  <td>Error responses that route to humans</td>
  <td>Health check endpoints</td>
  <td>Request queue (Redis, SQS)</td>
  <td>Middleware retry logic</td>
</tr>
</tbody>
</table></div>
<h3 id="103-the-priority-order">10.3 The priority order <a class="heading-anchor" href="#103-the-priority-order" aria-label="Link to this section">#</a></h3>
<p>If you're adding all five, do it in this order (highest value first):</p>
<ol>
<li><p><strong><code>agent.report_issue()</code></strong> — low effort, high value. Find 2-3 places where you log warnings about persistent problems and add <code>report_issue()</code>. Immediate pipeline tab visibility.</p>
</li>
<li><p><strong><code>task.plan()</code> + <code>task.plan_step()</code></strong> — medium effort. If your agent creates plans, this gives you the progress bar. If it doesn't create plans, skip this entirely.</p>
</li>
<li><p><strong><code>task.escalate()</code></strong> — low effort. Find the handoff point(s) and add one line each. Immediate Activity Stream visibility.</p>
</li>
<li><p><strong><code>agent.queue_snapshot()</code> or <code>queue_provider</code></strong> — low effort if you have a queue. Register the callback at agent creation time and forget about it.</p>
</li>
<li><p><strong><code>task.retry()</code></strong> — medium effort. Depends on how many retry patterns exist. Start with the most common retry loop.</p>
</li>
</ol>
<hr />
<h2 id="11-validation-checklists">11. Validation Checklists <a class="heading-anchor" href="#11-validation-checklists" aria-label="Link to this section">#</a></h2>
<p>After adding each method, verify on the dashboard.</p>
<h3 id="111-plans">11.1 Plans <a class="heading-anchor" href="#111-plans" aria-label="Link to this section">#</a></h3>
<ul>
<li>[ ] Trigger a task that creates a plan</li>
<li>[ ] <strong>Timeline</strong>: Plan progress bar appears above the timeline track</li>
<li>[ ] <strong>Timeline</strong>: Steps show correct colors (gray → blue → green or red)</li>
<li>[ ] <strong>Activity Stream</strong>: <code>plan_created</code> event appears with goal and step count</li>
<li>[ ] <strong>Activity Stream</strong>: <code>plan_step</code> events appear as steps progress</li>
<li>[ ] Trigger a step failure — verify red segment in plan bar</li>
</ul>
<h3 id="112-escalations">11.2 Escalations <a class="heading-anchor" href="#112-escalations" aria-label="Link to this section">#</a></h3>
<ul>
<li>[ ] Trigger a task that escalates</li>
<li>[ ] <strong>Timeline</strong>: Amber escalation node appears with summary text</li>
<li>[ ] <strong>Activity Stream</strong>: <code>escalated</code> event appears</li>
<li>[ ] <strong>Activity Stream</strong>: &quot;human&quot; filter includes the escalation event</li>
</ul>
<h3 id="113-issues">11.3 Issues <a class="heading-anchor" href="#113-issues" aria-label="Link to this section">#</a></h3>
<ul>
<li>[ ] Trigger an issue report (e.g., fail an API call 3 times)</li>
<li>[ ] <strong>Agent card</strong>: Red issue badge appears (e.g., &quot;● 1 issue&quot;)</li>
<li>[ ] <strong>Pipeline tab</strong>: Issue appears with correct severity and category</li>
<li>[ ] Resolve the issue — verify badge disappears</li>
<li>[ ] <strong>Activity Stream</strong>: Both report and resolve events appear</li>
</ul>
<h3 id="114-queue-snapshots">11.4 Queue snapshots <a class="heading-anchor" href="#114-queue-snapshots" aria-label="Link to this section">#</a></h3>
<ul>
<li>[ ] Register <code>queue_provider</code> on agent</li>
<li>[ ] Wait 30 seconds (one heartbeat cycle)</li>
<li>[ ] <strong>Agent card</strong>: Queue badge appears (e.g., &quot;Q:3&quot;)</li>
<li>[ ] <strong>Pipeline tab</strong>: Queue section shows items (if <code>items</code> array provided)</li>
<li>[ ] Add items to queue — verify badge count increases on next heartbeat</li>
</ul>
<h3 id="115-retries">11.5 Retries <a class="heading-anchor" href="#115-retries" aria-label="Link to this section">#</a></h3>
<ul>
<li>[ ] Trigger a task that retries an operation</li>
<li>[ ] <strong>Timeline</strong>: Retry nodes appear with attempt number</li>
<li>[ ] <strong>Activity Stream</strong>: <code>retry_started</code> events appear</li>
</ul>
<h3 id="116-tool-execution-tracking">11.6 Tool execution tracking <a class="heading-anchor" href="#116-tool-execution-tracking" aria-label="Link to this section">#</a></h3>
<ul>
<li>[ ] Trigger a turn with 1+ tool calls</li>
<li>[ ] <strong>Timeline</strong>: Blue action nodes appear with correct tool names</li>
<li>[ ] <strong>Timeline</strong>: Duration is shown on each node</li>
<li>[ ] Trigger a tool failure — verify red node with exception details</li>
<li>[ ] <strong>Activity Stream</strong>: <code>action_started</code> / <code>action_completed</code> events appear</li>
<li>[ ] Verify tool nodes appear between LLM call nodes in the correct sequence</li>
</ul>
<hr />
<h2 id="12-common-mistakes">12. Common Mistakes <a class="heading-anchor" href="#12-common-mistakes" aria-label="Link to this section">#</a></h2>
<h3 id="121-reporting-issues-inside-task-failure-handlers">12.1 Reporting issues inside task failure handlers <a class="heading-anchor" href="#121-reporting-issues-inside-task-failure-handlers" aria-label="Link to this section">#</a></h3>
<div class="code-block"><span class="code-lang">python</span><pre><code class="language-python"># ❌ Wrong — this reports an issue for every single failure:
except Exception as e:
    agent.report_issue(summary=str(e), severity=&quot;high&quot;)
</code></pre></div>
<p>Issues are for <strong>persistent</strong> problems, not individual failures. Track failure counts and only report when a threshold is crossed:</p>
<div class="code-block"><span class="code-lang">python</span><pre><code class="language-python"># ✅ Correct — only report after repeated failures:
except Exception as e:
    self.failure_count += 1
    if self.failure_count &gt;= 3:
        agent.report_issue(
            summary=f&quot;API consistently failing: {e}&quot;,
            severity=&quot;high&quot;,
            issue_id=&quot;api-failure&quot;,
            occurrence_count=self.failure_count,
        )
</code></pre></div>
<h3 id="122-forgetting-to-resolve-issues">12.2 Forgetting to resolve issues <a class="heading-anchor" href="#122-forgetting-to-resolve-issues" aria-label="Link to this section">#</a></h3>
<p>If you report an issue but never resolve it, the red badge stays on the agent card permanently. Always pair <code>report_issue()</code> with <code>resolve_issue()</code>:</p>
<div class="code-block"><span class="code-lang">python</span><pre><code class="language-python"># Report
agent.report_issue(..., issue_id=&quot;crm-403&quot;)

# Later, when the problem goes away:
agent.resolve_issue(&quot;CRM API recovered&quot;, issue_id=&quot;crm-403&quot;)
</code></pre></div>
<h3 id="123-using-queue_snapshot-too-frequently">12.3 Using <code>queue_snapshot()</code> too frequently <a class="heading-anchor" href="#123-using-queue_snapshot-too-frequently" aria-label="Link to this section">#</a></h3>
<p>Don't call <code>queue_snapshot()</code> on every enqueue/dequeue — it generates events. Use <code>queue_provider</code> for automatic periodic reporting, or call <code>queue_snapshot()</code> at most once per processing cycle.</p>
<h3 id="124-plan-step-indices-off-by-one">12.4 Plan step indices off by one <a class="heading-anchor" href="#124-plan-step-indices-off-by-one" aria-label="Link to this section">#</a></h3>
<p><code>task.plan()</code> creates zero-indexed steps. The first step is index 0, not 1:</p>
<div class="code-block"><span class="code-lang">python</span><pre><code class="language-python">task.plan(&quot;My plan&quot;, [&quot;Step A&quot;, &quot;Step B&quot;, &quot;Step C&quot;])
task.plan_step(0, &quot;started&quot;, &quot;Step A&quot;)    # ✅ correct
task.plan_step(1, &quot;started&quot;, &quot;Step A&quot;)    # ❌ wrong — this is Step B
</code></pre></div>
<h3 id="125-escalating-when-you-mean-to-request-approval">12.5 Escalating when you mean to request approval <a class="heading-anchor" href="#125-escalating-when-you-mean-to-request-approval" aria-label="Link to this section">#</a></h3>
<p>If the agent <strong>stops and waits</strong>, use <code>task.request_approval()</code>, not <code>task.escalate()</code>. Escalation means the agent hands off and moves on. Approval means the agent pauses until a human responds.</p>
<h3 id="126-not-using-issue_id">12.6 Not using <code>issue_id</code> <a class="heading-anchor" href="#126-not-using-issue_id" aria-label="Link to this section">#</a></h3>
<p>Without <code>issue_id</code>, the server deduplicates issues by hashing the summary text. If the summary includes variable data (timestamps, counts), each report creates a new issue instead of updating the existing one:</p>
<div class="code-block"><span class="code-lang">python</span><pre><code class="language-python"># ❌ Every call creates a new issue (summary changes each time):
agent.report_issue(
    summary=f&quot;API failed {count} times as of {datetime.now()}&quot;,
    severity=&quot;high&quot;,
)

# ✅ Updates the same issue each time:
agent.report_issue(
    summary=&quot;API consistently failing&quot;,
    severity=&quot;high&quot;,
    issue_id=&quot;api-failure&quot;,
    occurrence_count=count,
)
</code></pre></div>
<h3 id="127-calling-task-methods-outside-a-task-context">12.7 Calling task methods outside a task context <a class="heading-anchor" href="#127-calling-task-methods-outside-a-task-context" aria-label="Link to this section">#</a></h3>
<p><code>task.plan()</code>, <code>task.escalate()</code>, and <code>task.retry()</code> are <strong>task-scoped</strong> — they require an active task. If you call them outside a task context, they won't work.</p>
<p><code>agent.report_issue()</code> and <code>agent.queue_snapshot()</code> are <strong>agent-scoped</strong> — they work anywhere, with or without a task.</p>
<div class="code-block"><span class="code-lang">python</span><pre><code class="language-python"># ✅ Task-scoped methods — call on the task object:
with agent.task(task_id) as task:
    task.plan(...)
    task.escalate(...)
    task.retry(...)

# ✅ Agent-scoped methods — call on the agent object:
agent.report_issue(...)      # works anywhere
agent.queue_snapshot(...)    # works anywhere
</code></pre></div>

        </article>
        <div class="prev-next"><a class="prev-next-link prev" href="docs-layer2-llm-tracking.html"><span class="prev-next-label">← Previous</span><span class="prev-next-title">LLM Tracking</span></a><a class="prev-next-link next" href="docs-track-context.html"><span class="prev-next-label">Next →</span><span class="prev-next-title">Track Context</span></a></div>
    </main>

    <!-- RIGHT TOC -->
<nav class="page-toc"><div class="page-toc-title">On this page</div>
<a class="toc-link" href="#table-of-contents">Table of Contents</a>
<a class="toc-link" href="#1-what-this-guide-covers">1. What This Guide Covers</a>
<a class="toc-link toc-h3" href="#prerequisites">Prerequisites</a>
<a class="toc-link" href="#2-the-integration-mindset">2. The Integration Mindset</a>
<a class="toc-link toc-h3" href="#what-to-look-for">What to look for</a>
<a class="toc-link" href="#3-plans-taskplan-and-taskplan_step">3. Plans — task.plan() and task.plan_step()</a>
<a class="toc-link toc-h3" href="#31-what-it-does">3.1 What it does</a>
<a class="toc-link toc-h3" href="#32-the-api">3.2 The API</a>
<a class="toc-link toc-h3" href="#33-finding-where-to-add-plans">3.3 Finding WHERE to add plans</a>
<a class="toc-link toc-h3" href="#34-integration-pattern">3.4 Integration pattern</a>
<a class="toc-link toc-h3" href="#35-replanning">3.5 Replanning</a>
<a class="toc-link toc-h3" href="#36-loopcore-example">3.6 loopCore example</a>
<a class="toc-link toc-h3" href="#37-dashboard-impact">3.7 Dashboard impact</a>
<a class="toc-link" href="#4-escalations-taskescalate">4. Escalations — task.escalate()</a>
<a class="toc-link toc-h3" href="#41-what-it-does">4.1 What it does</a>
<a class="toc-link toc-h3" href="#42-the-api">4.2 The API</a>
<a class="toc-link toc-h3" href="#43-finding-where-to-add-escalations">4.3 Finding WHERE to add escalations</a>
<a class="toc-link toc-h3" href="#44-integration-pattern">4.4 Integration pattern</a>
<a class="toc-link toc-h3" href="#45-loopcore-example">4.5 loopCore example</a>
<a class="toc-link toc-h3" href="#46-escalation-vs-approval">4.6 Escalation vs. approval</a>
<a class="toc-link toc-h3" href="#47-dashboard-impact">4.7 Dashboard impact</a>
<a class="toc-link" href="#5-issues-agentreport_issue">5. Issues — agent.report_issue()</a>
<a class="toc-link toc-h3" href="#51-what-it-does">5.1 What it does</a>
<a class="toc-link toc-h3" href="#52-the-api">5.2 The API</a>
<a class="toc-link toc-h3" href="#53-issues-vs-task-failures-when-to-use-which">5.3 Issues vs. task failures — when to use which</a>
<a class="toc-link toc-h3" href="#54-finding-where-to-add-issue-reporting">5.4 Finding WHERE to add issue reporting</a>
<a class="toc-link toc-h3" href="#55-integration-pattern">5.5 Integration pattern</a>
<a class="toc-link toc-h3" href="#56-severity-guidelines">5.6 Severity guidelines</a>
<a class="toc-link toc-h3" href="#57-the-issue_id-pattern">5.7 The issue_id pattern</a>
<a class="toc-link toc-h3" href="#58-loopcore-example">5.8 loopCore example</a>
<a class="toc-link toc-h3" href="#59-dashboard-impact">5.9 Dashboard impact</a>
<a class="toc-link" href="#6-queue-snapshots-agentqueue_snapshot">6. Queue Snapshots — agent.queue_snapshot()</a>
<a class="toc-link toc-h3" href="#61-what-it-does">6.1 What it does</a>
<a class="toc-link toc-h3" href="#62-the-api">6.2 The API</a>
<a class="toc-link toc-h3" href="#63-two-ways-to-report-queue-state">6.3 Two ways to report queue state</a>
<a class="toc-link toc-h3" href="#64-finding-where-to-add-queue-snapshots">6.4 Finding WHERE to add queue snapshots</a>
<a class="toc-link toc-h3" href="#65-loopcore-example">6.5 loopCore example</a>
<a class="toc-link toc-h3" href="#66-dashboard-impact">6.6 Dashboard impact</a>
<a class="toc-link" href="#7-retries-taskretry">7. Retries — task.retry()</a>
<a class="toc-link toc-h3" href="#71-what-it-does">7.1 What it does</a>
<a class="toc-link toc-h3" href="#72-the-api">7.2 The API</a>
<a class="toc-link toc-h3" href="#73-finding-where-to-add-retries">7.3 Finding WHERE to add retries</a>
<a class="toc-link toc-h3" href="#74-integration-pattern">7.4 Integration pattern</a>
<a class="toc-link toc-h3" href="#75-loopcore-example">7.5 loopCore example</a>
<a class="toc-link toc-h3" href="#76-dashboard-impact">7.6 Dashboard impact</a>
<a class="toc-link" href="#8-tool-execution-tracking-agenttrack_context">8. Tool Execution Tracking — agent.track_context()</a>
<a class="toc-link toc-h3" href="#81-the-problem">8.1 The problem</a>
<a class="toc-link toc-h3" href="#82-the-method">8.2 The method</a>
<a class="toc-link toc-h3" href="#83-what-you-get-automatically">8.3 What you get automatically</a>
<a class="toc-link toc-h3" href="#84-the-full-turn-pattern">8.4 The full turn pattern</a>
<a class="toc-link toc-h3" href="#85-attaching-tool-metadata">8.5 Attaching tool metadata</a>
<a class="toc-link toc-h3" href="#86-turns-with-zero-tool-calls">8.6 Turns with zero tool calls</a>
<a class="toc-link toc-h3" href="#87-error-handling">8.7 Error handling</a>
<a class="toc-link toc-h3" href="#88-nested-tool-calls">8.8 Nested tool calls</a>
<a class="toc-link toc-h3" href="#89-loopcore-example">8.9 loopCore example</a>
<a class="toc-link toc-h3" href="#810-dashboard-impact">8.10 Dashboard impact</a>
<a class="toc-link toc-h3" href="#811-validation-checklist">8.11 Validation checklist</a>
<a class="toc-link" href="#9-putting-it-all-together">9. Putting It All Together</a>
<a class="toc-link" href="#10-finding-integration-points-in-your-codebase">10. Finding Integration Points in Your Codebase</a>
<a class="toc-link toc-h3" href="#101-use-this-prompt-with-your-llm">10.1 Use this prompt with your LLM</a>
<a class="toc-link toc-h3" href="#102-search-patterns-by-framework-type">10.2 Search patterns by framework type</a>
<a class="toc-link toc-h3" href="#103-the-priority-order">10.3 The priority order</a>
<a class="toc-link" href="#11-validation-checklists">11. Validation Checklists</a>
<a class="toc-link toc-h3" href="#111-plans">11.1 Plans</a>
<a class="toc-link toc-h3" href="#112-escalations">11.2 Escalations</a>
<a class="toc-link toc-h3" href="#113-issues">11.3 Issues</a>
<a class="toc-link toc-h3" href="#114-queue-snapshots">11.4 Queue snapshots</a>
<a class="toc-link toc-h3" href="#115-retries">11.5 Retries</a>
<a class="toc-link toc-h3" href="#116-tool-execution-tracking">11.6 Tool execution tracking</a>
<a class="toc-link" href="#12-common-mistakes">12. Common Mistakes</a>
<a class="toc-link toc-h3" href="#121-reporting-issues-inside-task-failure-handlers">12.1 Reporting issues inside task failure handlers</a>
<a class="toc-link toc-h3" href="#122-forgetting-to-resolve-issues">12.2 Forgetting to resolve issues</a>
<a class="toc-link toc-h3" href="#123-using-queue_snapshot-too-frequently">12.3 Using queue_snapshot() too frequently</a>
<a class="toc-link toc-h3" href="#124-plan-step-indices-off-by-one">12.4 Plan step indices off by one</a>
<a class="toc-link toc-h3" href="#125-escalating-when-you-mean-to-request-approval">12.5 Escalating when you mean to request approval</a>
<a class="toc-link toc-h3" href="#126-not-using-issue_id">12.6 Not using issue_id</a>
<a class="toc-link toc-h3" href="#127-calling-task-methods-outside-a-task-context">12.7 Calling task methods outside a task context</a>
</nav>

</div>

<!-- SCRIPTS -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-json.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-yaml.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-toml.min.js"></script>
<script>
// Re-highlight after load
Prism.highlightAll();

// Mobile menu toggle
document.getElementById('mobileMenuToggle')?.addEventListener('click', () => {
    document.getElementById('docsSidebar').classList.toggle('open');
});

// Close sidebar on content click (mobile)
document.querySelector('.docs-main')?.addEventListener('click', () => {
    document.getElementById('docsSidebar').classList.remove('open');
});

// Active TOC tracking
(function() {
    const tocLinks = document.querySelectorAll('.toc-link');
    if (!tocLinks.length) return;
    
    const headings = [];
    tocLinks.forEach(link => {
        const id = link.getAttribute('href')?.slice(1);
        const el = id && document.getElementById(id);
        if (el) headings.push({ el, link });
    });
    
    function updateActive() {
        let current = headings[0];
        for (const h of headings) {
            if (h.el.getBoundingClientRect().top <= 100) current = h;
        }
        tocLinks.forEach(l => l.classList.remove('active'));
        if (current) current.link.classList.add('active');
    }
    
    window.addEventListener('scroll', updateActive, { passive: true });
    updateActive();
})();

// Smooth scrolling for anchor links
document.querySelectorAll('a[href^="#"]').forEach(a => {
    a.addEventListener('click', e => {
        const target = document.querySelector(a.getAttribute('href'));
        if (target) {
            e.preventDefault();
            target.scrollIntoView({ behavior: 'smooth', block: 'start' });
            history.pushState(null, '', a.getAttribute('href'));
        }
    });
});
</script>
</body>
</html>
